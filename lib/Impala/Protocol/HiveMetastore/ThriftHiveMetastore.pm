#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use Impala::Protocol::HiveMetastore::Types;
use Impala::Protocol::fb303::FacebookService;

# HELPER FUNCTIONS AND STRUCTURES

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_database_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_database_args->mk_accessors( qw( database ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{database} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{database}) {
      $self->{database} = $vals->{database};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_create_database_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{database} = new Impala::Protocol::HiveMetastore::Database();
        $xfer += $self->{database}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_database_args');
  if (defined $self->{database}) {
    $xfer += $output->writeFieldBegin('database', TType::STRUCT, 1);
    $xfer += $self->{database}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_database_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_database_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_create_database_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::AlreadyExistsException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::InvalidObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_database_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_database_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_database_args->mk_accessors( qw( name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_database_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_database_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_database_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_database_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_database_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Impala::Protocol::HiveMetastore::Database();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_database_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_database_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_database_args->mk_accessors( qw( name deleteData cascade ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{deleteData} = undef;
  $self->{cascade} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{deleteData}) {
      $self->{deleteData} = $vals->{deleteData};
    }
    if (defined $vals->{cascade}) {
      $self->{cascade} = $vals->{cascade};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_database_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deleteData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{cascade});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_database_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleteData}) {
    $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{deleteData});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cascade}) {
    $xfer += $output->writeFieldBegin('cascade', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{cascade});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_database_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_database_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_database_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::InvalidOperationException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_database_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_databases_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_databases_args->mk_accessors( qw( pattern ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{pattern} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{pattern}) {
      $self->{pattern} = $vals->{pattern};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_databases_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{pattern});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_databases_args');
  if (defined $self->{pattern}) {
    $xfer += $output->writeFieldBegin('pattern', TType::STRING, 1);
    $xfer += $output->writeString($self->{pattern});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_databases_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_databases_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_databases_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size176 = 0;
          $self->{success} = [];
          my $_etype179 = 0;
          $xfer += $input->readListBegin(\$_etype179, \$_size176);
          for (my $_i180 = 0; $_i180 < $_size176; ++$_i180)
          {
            my $elem181 = undef;
            $xfer += $input->readString(\$elem181);
            push(@{$self->{success}},$elem181);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_databases_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter182 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter182);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_all_databases_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_all_databases_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_databases_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_all_databases_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_all_databases_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_all_databases_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size183 = 0;
          $self->{success} = [];
          my $_etype186 = 0;
          $xfer += $input->readListBegin(\$_etype186, \$_size183);
          for (my $_i187 = 0; $_i187 < $_size183; ++$_i187)
          {
            my $elem188 = undef;
            $xfer += $input->readString(\$elem188);
            push(@{$self->{success}},$elem188);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_databases_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter189 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter189);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_database_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_database_args->mk_accessors( qw( dbname db ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{dbname} = undef;
  $self->{db} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{dbname}) {
      $self->{dbname} = $vals->{dbname};
    }
    if (defined $vals->{db}) {
      $self->{db} = $vals->{db};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_alter_database_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dbname});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{db} = new Impala::Protocol::HiveMetastore::Database();
        $xfer += $self->{db}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_database_args');
  if (defined $self->{dbname}) {
    $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
    $xfer += $output->writeString($self->{dbname});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{db}) {
    $xfer += $output->writeFieldBegin('db', TType::STRUCT, 2);
    $xfer += $self->{db}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_database_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_database_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_alter_database_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_database_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_type_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_type_args->mk_accessors( qw( name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_type_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_type_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_type_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_type_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_type_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Impala::Protocol::HiveMetastore::Type();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_type_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_type_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_type_args->mk_accessors( qw( type ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{type} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_create_type_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{type} = new Impala::Protocol::HiveMetastore::Type();
        $xfer += $self->{type}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_type_args');
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::STRUCT, 1);
    $xfer += $self->{type}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_type_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_type_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_create_type_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::AlreadyExistsException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::InvalidObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_type_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_type_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_type_args->mk_accessors( qw( type ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{type} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_type_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_type_args');
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::STRING, 1);
    $xfer += $output->writeString($self->{type});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_type_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_type_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_type_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_type_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_type_all_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_type_all_args->mk_accessors( qw( name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_type_all_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_type_all_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_type_all_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_type_all_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_type_all_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size190 = 0;
          $self->{success} = {};
          my $_ktype191 = 0;
          my $_vtype192 = 0;
          $xfer += $input->readMapBegin(\$_ktype191, \$_vtype192, \$_size190);
          for (my $_i194 = 0; $_i194 < $_size190; ++$_i194)
          {
            my $key195 = '';
            my $val196 = new Impala::Protocol::HiveMetastore::Type();
            $xfer += $input->readString(\$key195);
            $val196 = new Impala::Protocol::HiveMetastore::Type();
            $xfer += $val196->read($input);
            $self->{success}->{$key195} = $val196;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_type_all_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter197,$viter198) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter197);
          $xfer += ${viter198}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 1);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_fields_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_fields_args->mk_accessors( qw( db_name table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_fields_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_fields_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_fields_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_fields_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_fields_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size199 = 0;
          $self->{success} = [];
          my $_etype202 = 0;
          $xfer += $input->readListBegin(\$_etype202, \$_size199);
          for (my $_i203 = 0; $_i203 < $_size199; ++$_i203)
          {
            my $elem204 = undef;
            $elem204 = new Impala::Protocol::HiveMetastore::FieldSchema();
            $xfer += $elem204->read($input);
            push(@{$self->{success}},$elem204);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::UnknownTableException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Impala::Protocol::HiveMetastore::UnknownDBException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_fields_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter205 (@{$self->{success}}) 
        {
          $xfer += ${iter205}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_schema_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_schema_args->mk_accessors( qw( db_name table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_schema_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_schema_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_schema_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_schema_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_schema_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size206 = 0;
          $self->{success} = [];
          my $_etype209 = 0;
          $xfer += $input->readListBegin(\$_etype209, \$_size206);
          for (my $_i210 = 0; $_i210 < $_size206; ++$_i210)
          {
            my $elem211 = undef;
            $elem211 = new Impala::Protocol::HiveMetastore::FieldSchema();
            $xfer += $elem211->read($input);
            push(@{$self->{success}},$elem211);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::UnknownTableException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Impala::Protocol::HiveMetastore::UnknownDBException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_schema_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter212 (@{$self->{success}}) 
        {
          $xfer += ${iter212}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_table_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_table_args->mk_accessors( qw( tbl ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tbl} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tbl}) {
      $self->{tbl} = $vals->{tbl};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_create_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tbl} = new Impala::Protocol::HiveMetastore::Table();
        $xfer += $self->{tbl}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_table_args');
  if (defined $self->{tbl}) {
    $xfer += $output->writeFieldBegin('tbl', TType::STRUCT, 1);
    $xfer += $self->{tbl}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_table_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_table_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  $self->{o4} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
    if (defined $vals->{o4}) {
      $self->{o4} = $vals->{o4};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_create_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::AlreadyExistsException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::InvalidObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o4} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o4}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_table_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o4}) {
    $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
    $xfer += $self->{o4}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_table_with_environment_context_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_table_with_environment_context_args->mk_accessors( qw( tbl environment_context ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tbl} = undef;
  $self->{environment_context} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tbl}) {
      $self->{tbl} = $vals->{tbl};
    }
    if (defined $vals->{environment_context}) {
      $self->{environment_context} = $vals->{environment_context};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_create_table_with_environment_context_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tbl} = new Impala::Protocol::HiveMetastore::Table();
        $xfer += $self->{tbl}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{environment_context} = new Impala::Protocol::HiveMetastore::EnvironmentContext();
        $xfer += $self->{environment_context}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_table_with_environment_context_args');
  if (defined $self->{tbl}) {
    $xfer += $output->writeFieldBegin('tbl', TType::STRUCT, 1);
    $xfer += $self->{tbl}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{environment_context}) {
    $xfer += $output->writeFieldBegin('environment_context', TType::STRUCT, 2);
    $xfer += $self->{environment_context}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_table_with_environment_context_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_table_with_environment_context_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  $self->{o4} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
    if (defined $vals->{o4}) {
      $self->{o4} = $vals->{o4};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_create_table_with_environment_context_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::AlreadyExistsException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::InvalidObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o4} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o4}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_table_with_environment_context_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o4}) {
    $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
    $xfer += $self->{o4}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_table_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_table_args->mk_accessors( qw( dbname name deleteData ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{dbname} = undef;
  $self->{name} = undef;
  $self->{deleteData} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{dbname}) {
      $self->{dbname} = $vals->{dbname};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{deleteData}) {
      $self->{deleteData} = $vals->{deleteData};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dbname});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deleteData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_table_args');
  if (defined $self->{dbname}) {
    $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
    $xfer += $output->writeString($self->{dbname});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleteData}) {
    $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{deleteData});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_table_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_table_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_table_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 2);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_tables_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_tables_args->mk_accessors( qw( db_name pattern ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{pattern} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{pattern}) {
      $self->{pattern} = $vals->{pattern};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_tables_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{pattern});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_tables_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{pattern}) {
    $xfer += $output->writeFieldBegin('pattern', TType::STRING, 2);
    $xfer += $output->writeString($self->{pattern});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_tables_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_tables_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_tables_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size213 = 0;
          $self->{success} = [];
          my $_etype216 = 0;
          $xfer += $input->readListBegin(\$_etype216, \$_size213);
          for (my $_i217 = 0; $_i217 < $_size213; ++$_i217)
          {
            my $elem218 = undef;
            $xfer += $input->readString(\$elem218);
            push(@{$self->{success}},$elem218);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_tables_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter219 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter219);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_all_tables_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_all_tables_args->mk_accessors( qw( db_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_all_tables_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_tables_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_all_tables_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_all_tables_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_all_tables_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size220 = 0;
          $self->{success} = [];
          my $_etype223 = 0;
          $xfer += $input->readListBegin(\$_etype223, \$_size220);
          for (my $_i224 = 0; $_i224 < $_size220; ++$_i224)
          {
            my $elem225 = undef;
            $xfer += $input->readString(\$elem225);
            push(@{$self->{success}},$elem225);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_tables_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter226 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter226);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_table_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_table_args->mk_accessors( qw( dbname tbl_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{dbname} = undef;
  $self->{tbl_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{dbname}) {
      $self->{dbname} = $vals->{dbname};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dbname});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_args');
  if (defined $self->{dbname}) {
    $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
    $xfer += $output->writeString($self->{dbname});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_table_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_table_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Impala::Protocol::HiveMetastore::Table();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_table_objects_by_name_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_table_objects_by_name_args->mk_accessors( qw( dbname tbl_names ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{dbname} = undef;
  $self->{tbl_names} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{dbname}) {
      $self->{dbname} = $vals->{dbname};
    }
    if (defined $vals->{tbl_names}) {
      $self->{tbl_names} = $vals->{tbl_names};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_table_objects_by_name_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dbname});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size227 = 0;
          $self->{tbl_names} = [];
          my $_etype230 = 0;
          $xfer += $input->readListBegin(\$_etype230, \$_size227);
          for (my $_i231 = 0; $_i231 < $_size227; ++$_i231)
          {
            my $elem232 = undef;
            $xfer += $input->readString(\$elem232);
            push(@{$self->{tbl_names}},$elem232);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_objects_by_name_args');
  if (defined $self->{dbname}) {
    $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
    $xfer += $output->writeString($self->{dbname});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_names}) {
    $xfer += $output->writeFieldBegin('tbl_names', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{tbl_names}}));
      {
        foreach my $iter233 (@{$self->{tbl_names}}) 
        {
          $xfer += $output->writeString($iter233);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_table_objects_by_name_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_table_objects_by_name_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_table_objects_by_name_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size234 = 0;
          $self->{success} = [];
          my $_etype237 = 0;
          $xfer += $input->readListBegin(\$_etype237, \$_size234);
          for (my $_i238 = 0; $_i238 < $_size234; ++$_i238)
          {
            my $elem239 = undef;
            $elem239 = new Impala::Protocol::HiveMetastore::Table();
            $xfer += $elem239->read($input);
            push(@{$self->{success}},$elem239);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::InvalidOperationException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Impala::Protocol::HiveMetastore::UnknownDBException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_objects_by_name_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter240 (@{$self->{success}}) 
        {
          $xfer += ${iter240}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_table_names_by_filter_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_table_names_by_filter_args->mk_accessors( qw( dbname filter max_tables ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{dbname} = undef;
  $self->{filter} = undef;
  $self->{max_tables} = -1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{dbname}) {
      $self->{dbname} = $vals->{dbname};
    }
    if (defined $vals->{filter}) {
      $self->{filter} = $vals->{filter};
    }
    if (defined $vals->{max_tables}) {
      $self->{max_tables} = $vals->{max_tables};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_table_names_by_filter_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dbname});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{filter});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{max_tables});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_names_by_filter_args');
  if (defined $self->{dbname}) {
    $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
    $xfer += $output->writeString($self->{dbname});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{filter}) {
    $xfer += $output->writeFieldBegin('filter', TType::STRING, 2);
    $xfer += $output->writeString($self->{filter});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_tables}) {
    $xfer += $output->writeFieldBegin('max_tables', TType::I16, 3);
    $xfer += $output->writeI16($self->{max_tables});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_table_names_by_filter_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_table_names_by_filter_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_table_names_by_filter_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size241 = 0;
          $self->{success} = [];
          my $_etype244 = 0;
          $xfer += $input->readListBegin(\$_etype244, \$_size241);
          for (my $_i245 = 0; $_i245 < $_size241; ++$_i245)
          {
            my $elem246 = undef;
            $xfer += $input->readString(\$elem246);
            push(@{$self->{success}},$elem246);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::InvalidOperationException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Impala::Protocol::HiveMetastore::UnknownDBException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_names_by_filter_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter247 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter247);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_table_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_table_args->mk_accessors( qw( dbname tbl_name new_tbl ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{dbname} = undef;
  $self->{tbl_name} = undef;
  $self->{new_tbl} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{dbname}) {
      $self->{dbname} = $vals->{dbname};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{new_tbl}) {
      $self->{new_tbl} = $vals->{new_tbl};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_alter_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dbname});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{new_tbl} = new Impala::Protocol::HiveMetastore::Table();
        $xfer += $self->{new_tbl}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_table_args');
  if (defined $self->{dbname}) {
    $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
    $xfer += $output->writeString($self->{dbname});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{new_tbl}) {
    $xfer += $output->writeFieldBegin('new_tbl', TType::STRUCT, 3);
    $xfer += $self->{new_tbl}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_table_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_table_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_alter_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::InvalidOperationException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_table_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_table_with_environment_context_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_table_with_environment_context_args->mk_accessors( qw( dbname tbl_name new_tbl environment_context ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{dbname} = undef;
  $self->{tbl_name} = undef;
  $self->{new_tbl} = undef;
  $self->{environment_context} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{dbname}) {
      $self->{dbname} = $vals->{dbname};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{new_tbl}) {
      $self->{new_tbl} = $vals->{new_tbl};
    }
    if (defined $vals->{environment_context}) {
      $self->{environment_context} = $vals->{environment_context};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_alter_table_with_environment_context_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dbname});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{new_tbl} = new Impala::Protocol::HiveMetastore::Table();
        $xfer += $self->{new_tbl}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{environment_context} = new Impala::Protocol::HiveMetastore::EnvironmentContext();
        $xfer += $self->{environment_context}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_table_with_environment_context_args');
  if (defined $self->{dbname}) {
    $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
    $xfer += $output->writeString($self->{dbname});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{new_tbl}) {
    $xfer += $output->writeFieldBegin('new_tbl', TType::STRUCT, 3);
    $xfer += $self->{new_tbl}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{environment_context}) {
    $xfer += $output->writeFieldBegin('environment_context', TType::STRUCT, 4);
    $xfer += $self->{environment_context}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_table_with_environment_context_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_table_with_environment_context_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_alter_table_with_environment_context_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::InvalidOperationException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_table_with_environment_context_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_partition_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_partition_args->mk_accessors( qw( new_part ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{new_part} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{new_part}) {
      $self->{new_part} = $vals->{new_part};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_add_partition_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{new_part} = new Impala::Protocol::HiveMetastore::Partition();
        $xfer += $self->{new_part}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partition_args');
  if (defined $self->{new_part}) {
    $xfer += $output->writeFieldBegin('new_part', TType::STRUCT, 1);
    $xfer += $self->{new_part}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_partition_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_partition_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_add_partition_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Impala::Protocol::HiveMetastore::Partition();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::InvalidObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::AlreadyExistsException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partition_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_partition_with_environment_context_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_partition_with_environment_context_args->mk_accessors( qw( new_part environment_context ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{new_part} = undef;
  $self->{environment_context} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{new_part}) {
      $self->{new_part} = $vals->{new_part};
    }
    if (defined $vals->{environment_context}) {
      $self->{environment_context} = $vals->{environment_context};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_add_partition_with_environment_context_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{new_part} = new Impala::Protocol::HiveMetastore::Partition();
        $xfer += $self->{new_part}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{environment_context} = new Impala::Protocol::HiveMetastore::EnvironmentContext();
        $xfer += $self->{environment_context}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partition_with_environment_context_args');
  if (defined $self->{new_part}) {
    $xfer += $output->writeFieldBegin('new_part', TType::STRUCT, 1);
    $xfer += $self->{new_part}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{environment_context}) {
    $xfer += $output->writeFieldBegin('environment_context', TType::STRUCT, 2);
    $xfer += $self->{environment_context}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_partition_with_environment_context_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_partition_with_environment_context_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_add_partition_with_environment_context_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Impala::Protocol::HiveMetastore::Partition();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::InvalidObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::AlreadyExistsException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partition_with_environment_context_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_partitions_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_partitions_args->mk_accessors( qw( new_parts ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{new_parts} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{new_parts}) {
      $self->{new_parts} = $vals->{new_parts};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_add_partitions_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size248 = 0;
          $self->{new_parts} = [];
          my $_etype251 = 0;
          $xfer += $input->readListBegin(\$_etype251, \$_size248);
          for (my $_i252 = 0; $_i252 < $_size248; ++$_i252)
          {
            my $elem253 = undef;
            $elem253 = new Impala::Protocol::HiveMetastore::Partition();
            $xfer += $elem253->read($input);
            push(@{$self->{new_parts}},$elem253);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partitions_args');
  if (defined $self->{new_parts}) {
    $xfer += $output->writeFieldBegin('new_parts', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{new_parts}}));
      {
        foreach my $iter254 (@{$self->{new_parts}}) 
        {
          $xfer += ${iter254}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_partitions_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_partitions_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_add_partitions_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::InvalidObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::AlreadyExistsException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partitions_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_append_partition_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_append_partition_args->mk_accessors( qw( db_name tbl_name part_vals ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_vals} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_vals}) {
      $self->{part_vals} = $vals->{part_vals};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_append_partition_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size255 = 0;
          $self->{part_vals} = [];
          my $_etype258 = 0;
          $xfer += $input->readListBegin(\$_etype258, \$_size255);
          for (my $_i259 = 0; $_i259 < $_size255; ++$_i259)
          {
            my $elem260 = undef;
            $xfer += $input->readString(\$elem260);
            push(@{$self->{part_vals}},$elem260);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_partition_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_vals}) {
    $xfer += $output->writeFieldBegin('part_vals', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{part_vals}}));
      {
        foreach my $iter261 (@{$self->{part_vals}}) 
        {
          $xfer += $output->writeString($iter261);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_append_partition_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_append_partition_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_append_partition_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Impala::Protocol::HiveMetastore::Partition();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::InvalidObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::AlreadyExistsException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_partition_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_append_partition_by_name_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_append_partition_by_name_args->mk_accessors( qw( db_name tbl_name part_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_name}) {
      $self->{part_name} = $vals->{part_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_append_partition_by_name_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{part_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_partition_by_name_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_name}) {
    $xfer += $output->writeFieldBegin('part_name', TType::STRING, 3);
    $xfer += $output->writeString($self->{part_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_append_partition_by_name_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_append_partition_by_name_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_append_partition_by_name_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Impala::Protocol::HiveMetastore::Partition();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::InvalidObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::AlreadyExistsException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_partition_by_name_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_partition_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_partition_args->mk_accessors( qw( db_name tbl_name part_vals deleteData ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_vals} = undef;
  $self->{deleteData} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_vals}) {
      $self->{part_vals} = $vals->{part_vals};
    }
    if (defined $vals->{deleteData}) {
      $self->{deleteData} = $vals->{deleteData};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_partition_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size262 = 0;
          $self->{part_vals} = [];
          my $_etype265 = 0;
          $xfer += $input->readListBegin(\$_etype265, \$_size262);
          for (my $_i266 = 0; $_i266 < $_size262; ++$_i266)
          {
            my $elem267 = undef;
            $xfer += $input->readString(\$elem267);
            push(@{$self->{part_vals}},$elem267);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deleteData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_vals}) {
    $xfer += $output->writeFieldBegin('part_vals', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{part_vals}}));
      {
        foreach my $iter268 (@{$self->{part_vals}}) 
        {
          $xfer += $output->writeString($iter268);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleteData}) {
    $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{deleteData});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_partition_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_partition_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_partition_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_partition_by_name_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_partition_by_name_args->mk_accessors( qw( db_name tbl_name part_name deleteData ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_name} = undef;
  $self->{deleteData} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_name}) {
      $self->{part_name} = $vals->{part_name};
    }
    if (defined $vals->{deleteData}) {
      $self->{deleteData} = $vals->{deleteData};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_partition_by_name_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{part_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deleteData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_by_name_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_name}) {
    $xfer += $output->writeFieldBegin('part_name', TType::STRING, 3);
    $xfer += $output->writeString($self->{part_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleteData}) {
    $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{deleteData});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_partition_by_name_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_partition_by_name_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_partition_by_name_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_by_name_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_args->mk_accessors( qw( db_name tbl_name part_vals ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_vals} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_vals}) {
      $self->{part_vals} = $vals->{part_vals};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size269 = 0;
          $self->{part_vals} = [];
          my $_etype272 = 0;
          $xfer += $input->readListBegin(\$_etype272, \$_size269);
          for (my $_i273 = 0; $_i273 < $_size269; ++$_i273)
          {
            my $elem274 = undef;
            $xfer += $input->readString(\$elem274);
            push(@{$self->{part_vals}},$elem274);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_vals}) {
    $xfer += $output->writeFieldBegin('part_vals', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{part_vals}}));
      {
        foreach my $iter275 (@{$self->{part_vals}}) 
        {
          $xfer += $output->writeString($iter275);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Impala::Protocol::HiveMetastore::Partition();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_with_auth_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_with_auth_args->mk_accessors( qw( db_name tbl_name part_vals user_name group_names ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_vals} = undef;
  $self->{user_name} = undef;
  $self->{group_names} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_vals}) {
      $self->{part_vals} = $vals->{part_vals};
    }
    if (defined $vals->{user_name}) {
      $self->{user_name} = $vals->{user_name};
    }
    if (defined $vals->{group_names}) {
      $self->{group_names} = $vals->{group_names};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_with_auth_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size276 = 0;
          $self->{part_vals} = [];
          my $_etype279 = 0;
          $xfer += $input->readListBegin(\$_etype279, \$_size276);
          for (my $_i280 = 0; $_i280 < $_size276; ++$_i280)
          {
            my $elem281 = undef;
            $xfer += $input->readString(\$elem281);
            push(@{$self->{part_vals}},$elem281);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{user_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size282 = 0;
          $self->{group_names} = [];
          my $_etype285 = 0;
          $xfer += $input->readListBegin(\$_etype285, \$_size282);
          for (my $_i286 = 0; $_i286 < $_size282; ++$_i286)
          {
            my $elem287 = undef;
            $xfer += $input->readString(\$elem287);
            push(@{$self->{group_names}},$elem287);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_with_auth_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_vals}) {
    $xfer += $output->writeFieldBegin('part_vals', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{part_vals}}));
      {
        foreach my $iter288 (@{$self->{part_vals}}) 
        {
          $xfer += $output->writeString($iter288);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{user_name}) {
    $xfer += $output->writeFieldBegin('user_name', TType::STRING, 4);
    $xfer += $output->writeString($self->{user_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{group_names}) {
    $xfer += $output->writeFieldBegin('group_names', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{group_names}}));
      {
        foreach my $iter289 (@{$self->{group_names}}) 
        {
          $xfer += $output->writeString($iter289);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_with_auth_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_with_auth_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_with_auth_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Impala::Protocol::HiveMetastore::Partition();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_with_auth_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_by_name_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_by_name_args->mk_accessors( qw( db_name tbl_name part_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_name}) {
      $self->{part_name} = $vals->{part_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_by_name_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{part_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_by_name_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_name}) {
    $xfer += $output->writeFieldBegin('part_name', TType::STRING, 3);
    $xfer += $output->writeString($self->{part_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_by_name_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_by_name_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_by_name_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Impala::Protocol::HiveMetastore::Partition();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_by_name_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_args->mk_accessors( qw( db_name tbl_name max_parts ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{max_parts} = -1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{max_parts}) {
      $self->{max_parts} = $vals->{max_parts};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{max_parts});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_parts}) {
    $xfer += $output->writeFieldBegin('max_parts', TType::I16, 3);
    $xfer += $output->writeI16($self->{max_parts});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size290 = 0;
          $self->{success} = [];
          my $_etype293 = 0;
          $xfer += $input->readListBegin(\$_etype293, \$_size290);
          for (my $_i294 = 0; $_i294 < $_size290; ++$_i294)
          {
            my $elem295 = undef;
            $elem295 = new Impala::Protocol::HiveMetastore::Partition();
            $xfer += $elem295->read($input);
            push(@{$self->{success}},$elem295);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter296 (@{$self->{success}}) 
        {
          $xfer += ${iter296}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_with_auth_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_with_auth_args->mk_accessors( qw( db_name tbl_name max_parts user_name group_names ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{max_parts} = -1;
  $self->{user_name} = undef;
  $self->{group_names} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{max_parts}) {
      $self->{max_parts} = $vals->{max_parts};
    }
    if (defined $vals->{user_name}) {
      $self->{user_name} = $vals->{user_name};
    }
    if (defined $vals->{group_names}) {
      $self->{group_names} = $vals->{group_names};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_with_auth_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{max_parts});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{user_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size297 = 0;
          $self->{group_names} = [];
          my $_etype300 = 0;
          $xfer += $input->readListBegin(\$_etype300, \$_size297);
          for (my $_i301 = 0; $_i301 < $_size297; ++$_i301)
          {
            my $elem302 = undef;
            $xfer += $input->readString(\$elem302);
            push(@{$self->{group_names}},$elem302);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_with_auth_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_parts}) {
    $xfer += $output->writeFieldBegin('max_parts', TType::I16, 3);
    $xfer += $output->writeI16($self->{max_parts});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{user_name}) {
    $xfer += $output->writeFieldBegin('user_name', TType::STRING, 4);
    $xfer += $output->writeString($self->{user_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{group_names}) {
    $xfer += $output->writeFieldBegin('group_names', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{group_names}}));
      {
        foreach my $iter303 (@{$self->{group_names}}) 
        {
          $xfer += $output->writeString($iter303);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_with_auth_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_with_auth_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_with_auth_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size304 = 0;
          $self->{success} = [];
          my $_etype307 = 0;
          $xfer += $input->readListBegin(\$_etype307, \$_size304);
          for (my $_i308 = 0; $_i308 < $_size304; ++$_i308)
          {
            my $elem309 = undef;
            $elem309 = new Impala::Protocol::HiveMetastore::Partition();
            $xfer += $elem309->read($input);
            push(@{$self->{success}},$elem309);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_with_auth_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter310 (@{$self->{success}}) 
        {
          $xfer += ${iter310}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_names_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_names_args->mk_accessors( qw( db_name tbl_name max_parts ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{max_parts} = -1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{max_parts}) {
      $self->{max_parts} = $vals->{max_parts};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_names_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{max_parts});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_names_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_parts}) {
    $xfer += $output->writeFieldBegin('max_parts', TType::I16, 3);
    $xfer += $output->writeI16($self->{max_parts});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_names_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_names_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_names_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size311 = 0;
          $self->{success} = [];
          my $_etype314 = 0;
          $xfer += $input->readListBegin(\$_etype314, \$_size311);
          for (my $_i315 = 0; $_i315 < $_size311; ++$_i315)
          {
            my $elem316 = undef;
            $xfer += $input->readString(\$elem316);
            push(@{$self->{success}},$elem316);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_names_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter317 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter317);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 1);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_ps_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_ps_args->mk_accessors( qw( db_name tbl_name part_vals max_parts ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_vals} = undef;
  $self->{max_parts} = -1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_vals}) {
      $self->{part_vals} = $vals->{part_vals};
    }
    if (defined $vals->{max_parts}) {
      $self->{max_parts} = $vals->{max_parts};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_ps_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size318 = 0;
          $self->{part_vals} = [];
          my $_etype321 = 0;
          $xfer += $input->readListBegin(\$_etype321, \$_size318);
          for (my $_i322 = 0; $_i322 < $_size318; ++$_i322)
          {
            my $elem323 = undef;
            $xfer += $input->readString(\$elem323);
            push(@{$self->{part_vals}},$elem323);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{max_parts});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_ps_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_vals}) {
    $xfer += $output->writeFieldBegin('part_vals', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{part_vals}}));
      {
        foreach my $iter324 (@{$self->{part_vals}}) 
        {
          $xfer += $output->writeString($iter324);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_parts}) {
    $xfer += $output->writeFieldBegin('max_parts', TType::I16, 4);
    $xfer += $output->writeI16($self->{max_parts});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_ps_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_ps_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_ps_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size325 = 0;
          $self->{success} = [];
          my $_etype328 = 0;
          $xfer += $input->readListBegin(\$_etype328, \$_size325);
          for (my $_i329 = 0; $_i329 < $_size325; ++$_i329)
          {
            my $elem330 = undef;
            $elem330 = new Impala::Protocol::HiveMetastore::Partition();
            $xfer += $elem330->read($input);
            push(@{$self->{success}},$elem330);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_ps_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter331 (@{$self->{success}}) 
        {
          $xfer += ${iter331}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_ps_with_auth_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_ps_with_auth_args->mk_accessors( qw( db_name tbl_name part_vals max_parts user_name group_names ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_vals} = undef;
  $self->{max_parts} = -1;
  $self->{user_name} = undef;
  $self->{group_names} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_vals}) {
      $self->{part_vals} = $vals->{part_vals};
    }
    if (defined $vals->{max_parts}) {
      $self->{max_parts} = $vals->{max_parts};
    }
    if (defined $vals->{user_name}) {
      $self->{user_name} = $vals->{user_name};
    }
    if (defined $vals->{group_names}) {
      $self->{group_names} = $vals->{group_names};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_ps_with_auth_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size332 = 0;
          $self->{part_vals} = [];
          my $_etype335 = 0;
          $xfer += $input->readListBegin(\$_etype335, \$_size332);
          for (my $_i336 = 0; $_i336 < $_size332; ++$_i336)
          {
            my $elem337 = undef;
            $xfer += $input->readString(\$elem337);
            push(@{$self->{part_vals}},$elem337);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{max_parts});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{user_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size338 = 0;
          $self->{group_names} = [];
          my $_etype341 = 0;
          $xfer += $input->readListBegin(\$_etype341, \$_size338);
          for (my $_i342 = 0; $_i342 < $_size338; ++$_i342)
          {
            my $elem343 = undef;
            $xfer += $input->readString(\$elem343);
            push(@{$self->{group_names}},$elem343);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_ps_with_auth_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_vals}) {
    $xfer += $output->writeFieldBegin('part_vals', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{part_vals}}));
      {
        foreach my $iter344 (@{$self->{part_vals}}) 
        {
          $xfer += $output->writeString($iter344);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_parts}) {
    $xfer += $output->writeFieldBegin('max_parts', TType::I16, 4);
    $xfer += $output->writeI16($self->{max_parts});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{user_name}) {
    $xfer += $output->writeFieldBegin('user_name', TType::STRING, 5);
    $xfer += $output->writeString($self->{user_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{group_names}) {
    $xfer += $output->writeFieldBegin('group_names', TType::LIST, 6);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{group_names}}));
      {
        foreach my $iter345 (@{$self->{group_names}}) 
        {
          $xfer += $output->writeString($iter345);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_ps_with_auth_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_ps_with_auth_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_ps_with_auth_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size346 = 0;
          $self->{success} = [];
          my $_etype349 = 0;
          $xfer += $input->readListBegin(\$_etype349, \$_size346);
          for (my $_i350 = 0; $_i350 < $_size346; ++$_i350)
          {
            my $elem351 = undef;
            $elem351 = new Impala::Protocol::HiveMetastore::Partition();
            $xfer += $elem351->read($input);
            push(@{$self->{success}},$elem351);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_ps_with_auth_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter352 (@{$self->{success}}) 
        {
          $xfer += ${iter352}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_names_ps_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_names_ps_args->mk_accessors( qw( db_name tbl_name part_vals max_parts ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_vals} = undef;
  $self->{max_parts} = -1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_vals}) {
      $self->{part_vals} = $vals->{part_vals};
    }
    if (defined $vals->{max_parts}) {
      $self->{max_parts} = $vals->{max_parts};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_names_ps_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size353 = 0;
          $self->{part_vals} = [];
          my $_etype356 = 0;
          $xfer += $input->readListBegin(\$_etype356, \$_size353);
          for (my $_i357 = 0; $_i357 < $_size353; ++$_i357)
          {
            my $elem358 = undef;
            $xfer += $input->readString(\$elem358);
            push(@{$self->{part_vals}},$elem358);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{max_parts});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_names_ps_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_vals}) {
    $xfer += $output->writeFieldBegin('part_vals', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{part_vals}}));
      {
        foreach my $iter359 (@{$self->{part_vals}}) 
        {
          $xfer += $output->writeString($iter359);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_parts}) {
    $xfer += $output->writeFieldBegin('max_parts', TType::I16, 4);
    $xfer += $output->writeI16($self->{max_parts});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_names_ps_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_names_ps_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_names_ps_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size360 = 0;
          $self->{success} = [];
          my $_etype363 = 0;
          $xfer += $input->readListBegin(\$_etype363, \$_size360);
          for (my $_i364 = 0; $_i364 < $_size360; ++$_i364)
          {
            my $elem365 = undef;
            $xfer += $input->readString(\$elem365);
            push(@{$self->{success}},$elem365);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_names_ps_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter366 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter366);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_by_filter_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_by_filter_args->mk_accessors( qw( db_name tbl_name filter max_parts ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{filter} = undef;
  $self->{max_parts} = -1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{filter}) {
      $self->{filter} = $vals->{filter};
    }
    if (defined $vals->{max_parts}) {
      $self->{max_parts} = $vals->{max_parts};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_by_filter_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{filter});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{max_parts});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_by_filter_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{filter}) {
    $xfer += $output->writeFieldBegin('filter', TType::STRING, 3);
    $xfer += $output->writeString($self->{filter});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_parts}) {
    $xfer += $output->writeFieldBegin('max_parts', TType::I16, 4);
    $xfer += $output->writeI16($self->{max_parts});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_by_filter_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_by_filter_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_by_filter_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size367 = 0;
          $self->{success} = [];
          my $_etype370 = 0;
          $xfer += $input->readListBegin(\$_etype370, \$_size367);
          for (my $_i371 = 0; $_i371 < $_size367; ++$_i371)
          {
            my $elem372 = undef;
            $elem372 = new Impala::Protocol::HiveMetastore::Partition();
            $xfer += $elem372->read($input);
            push(@{$self->{success}},$elem372);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_by_filter_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter373 (@{$self->{success}}) 
        {
          $xfer += ${iter373}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_by_names_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_by_names_args->mk_accessors( qw( db_name tbl_name names ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{names} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{names}) {
      $self->{names} = $vals->{names};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_by_names_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size374 = 0;
          $self->{names} = [];
          my $_etype377 = 0;
          $xfer += $input->readListBegin(\$_etype377, \$_size374);
          for (my $_i378 = 0; $_i378 < $_size374; ++$_i378)
          {
            my $elem379 = undef;
            $xfer += $input->readString(\$elem379);
            push(@{$self->{names}},$elem379);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_by_names_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{names}) {
    $xfer += $output->writeFieldBegin('names', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{names}}));
      {
        foreach my $iter380 (@{$self->{names}}) 
        {
          $xfer += $output->writeString($iter380);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_by_names_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_by_names_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_by_names_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size381 = 0;
          $self->{success} = [];
          my $_etype384 = 0;
          $xfer += $input->readListBegin(\$_etype384, \$_size381);
          for (my $_i385 = 0; $_i385 < $_size381; ++$_i385)
          {
            my $elem386 = undef;
            $elem386 = new Impala::Protocol::HiveMetastore::Partition();
            $xfer += $elem386->read($input);
            push(@{$self->{success}},$elem386);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_by_names_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter387 (@{$self->{success}}) 
        {
          $xfer += ${iter387}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_partition_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_partition_args->mk_accessors( qw( db_name tbl_name new_part ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{new_part} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{new_part}) {
      $self->{new_part} = $vals->{new_part};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_alter_partition_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{new_part} = new Impala::Protocol::HiveMetastore::Partition();
        $xfer += $self->{new_part}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_partition_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{new_part}) {
    $xfer += $output->writeFieldBegin('new_part', TType::STRUCT, 3);
    $xfer += $self->{new_part}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_partition_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_partition_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_alter_partition_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::InvalidOperationException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_partition_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_partition_with_environment_context_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_partition_with_environment_context_args->mk_accessors( qw( db_name tbl_name new_part environment_context ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{new_part} = undef;
  $self->{environment_context} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{new_part}) {
      $self->{new_part} = $vals->{new_part};
    }
    if (defined $vals->{environment_context}) {
      $self->{environment_context} = $vals->{environment_context};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_alter_partition_with_environment_context_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{new_part} = new Impala::Protocol::HiveMetastore::Partition();
        $xfer += $self->{new_part}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{environment_context} = new Impala::Protocol::HiveMetastore::EnvironmentContext();
        $xfer += $self->{environment_context}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_partition_with_environment_context_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{new_part}) {
    $xfer += $output->writeFieldBegin('new_part', TType::STRUCT, 3);
    $xfer += $self->{new_part}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{environment_context}) {
    $xfer += $output->writeFieldBegin('environment_context', TType::STRUCT, 4);
    $xfer += $self->{environment_context}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_partition_with_environment_context_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_partition_with_environment_context_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_alter_partition_with_environment_context_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::InvalidOperationException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_partition_with_environment_context_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_rename_partition_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_rename_partition_args->mk_accessors( qw( db_name tbl_name part_vals new_part ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_vals} = undef;
  $self->{new_part} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_vals}) {
      $self->{part_vals} = $vals->{part_vals};
    }
    if (defined $vals->{new_part}) {
      $self->{new_part} = $vals->{new_part};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_rename_partition_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size388 = 0;
          $self->{part_vals} = [];
          my $_etype391 = 0;
          $xfer += $input->readListBegin(\$_etype391, \$_size388);
          for (my $_i392 = 0; $_i392 < $_size388; ++$_i392)
          {
            my $elem393 = undef;
            $xfer += $input->readString(\$elem393);
            push(@{$self->{part_vals}},$elem393);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{new_part} = new Impala::Protocol::HiveMetastore::Partition();
        $xfer += $self->{new_part}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_rename_partition_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_vals}) {
    $xfer += $output->writeFieldBegin('part_vals', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{part_vals}}));
      {
        foreach my $iter394 (@{$self->{part_vals}}) 
        {
          $xfer += $output->writeString($iter394);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{new_part}) {
    $xfer += $output->writeFieldBegin('new_part', TType::STRUCT, 4);
    $xfer += $self->{new_part}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_rename_partition_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_rename_partition_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_rename_partition_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::InvalidOperationException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_rename_partition_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_config_value_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_config_value_args->mk_accessors( qw( name defaultValue ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{defaultValue} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{defaultValue}) {
      $self->{defaultValue} = $vals->{defaultValue};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_config_value_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{defaultValue});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_config_value_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{defaultValue}) {
    $xfer += $output->writeFieldBegin('defaultValue', TType::STRING, 2);
    $xfer += $output->writeString($self->{defaultValue});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_config_value_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_config_value_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_config_value_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::ConfigValSecurityException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_config_value_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_partition_name_to_vals_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_partition_name_to_vals_args->mk_accessors( qw( part_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{part_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{part_name}) {
      $self->{part_name} = $vals->{part_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_partition_name_to_vals_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{part_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_partition_name_to_vals_args');
  if (defined $self->{part_name}) {
    $xfer += $output->writeFieldBegin('part_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{part_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_partition_name_to_vals_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_partition_name_to_vals_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_partition_name_to_vals_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size395 = 0;
          $self->{success} = [];
          my $_etype398 = 0;
          $xfer += $input->readListBegin(\$_etype398, \$_size395);
          for (my $_i399 = 0; $_i399 < $_size395; ++$_i399)
          {
            my $elem400 = undef;
            $xfer += $input->readString(\$elem400);
            push(@{$self->{success}},$elem400);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_partition_name_to_vals_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter401 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter401);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_partition_name_to_spec_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_partition_name_to_spec_args->mk_accessors( qw( part_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{part_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{part_name}) {
      $self->{part_name} = $vals->{part_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_partition_name_to_spec_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{part_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_partition_name_to_spec_args');
  if (defined $self->{part_name}) {
    $xfer += $output->writeFieldBegin('part_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{part_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_partition_name_to_spec_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_partition_name_to_spec_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_partition_name_to_spec_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size402 = 0;
          $self->{success} = {};
          my $_ktype403 = 0;
          my $_vtype404 = 0;
          $xfer += $input->readMapBegin(\$_ktype403, \$_vtype404, \$_size402);
          for (my $_i406 = 0; $_i406 < $_size402; ++$_i406)
          {
            my $key407 = '';
            my $val408 = '';
            $xfer += $input->readString(\$key407);
            $xfer += $input->readString(\$val408);
            $self->{success}->{$key407} = $val408;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_partition_name_to_spec_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter409,$viter410) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter409);
          $xfer += $output->writeString($viter410);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_markPartitionForEvent_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_markPartitionForEvent_args->mk_accessors( qw( db_name tbl_name part_vals eventType ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_vals} = undef;
  $self->{eventType} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_vals}) {
      $self->{part_vals} = $vals->{part_vals};
    }
    if (defined $vals->{eventType}) {
      $self->{eventType} = $vals->{eventType};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_markPartitionForEvent_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size411 = 0;
          $self->{part_vals} = {};
          my $_ktype412 = 0;
          my $_vtype413 = 0;
          $xfer += $input->readMapBegin(\$_ktype412, \$_vtype413, \$_size411);
          for (my $_i415 = 0; $_i415 < $_size411; ++$_i415)
          {
            my $key416 = '';
            my $val417 = '';
            $xfer += $input->readString(\$key416);
            $xfer += $input->readString(\$val417);
            $self->{part_vals}->{$key416} = $val417;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{eventType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_markPartitionForEvent_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_vals}) {
    $xfer += $output->writeFieldBegin('part_vals', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{part_vals}}));
      {
        while( my ($kiter418,$viter419) = each %{$self->{part_vals}}) 
        {
          $xfer += $output->writeString($kiter418);
          $xfer += $output->writeString($viter419);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{eventType}) {
    $xfer += $output->writeFieldBegin('eventType', TType::I32, 4);
    $xfer += $output->writeI32($self->{eventType});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_markPartitionForEvent_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_markPartitionForEvent_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  $self->{o4} = undef;
  $self->{o5} = undef;
  $self->{o6} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
    if (defined $vals->{o4}) {
      $self->{o4} = $vals->{o4};
    }
    if (defined $vals->{o5}) {
      $self->{o5} = $vals->{o5};
    }
    if (defined $vals->{o6}) {
      $self->{o6} = $vals->{o6};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_markPartitionForEvent_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Impala::Protocol::HiveMetastore::UnknownDBException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o4} = new Impala::Protocol::HiveMetastore::UnknownTableException();
        $xfer += $self->{o4}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o5} = new Impala::Protocol::HiveMetastore::UnknownPartitionException();
        $xfer += $self->{o5}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o6} = new Impala::Protocol::HiveMetastore::InvalidPartitionException();
        $xfer += $self->{o6}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_markPartitionForEvent_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o4}) {
    $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
    $xfer += $self->{o4}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o5}) {
    $xfer += $output->writeFieldBegin('o5', TType::STRUCT, 5);
    $xfer += $self->{o5}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o6}) {
    $xfer += $output->writeFieldBegin('o6', TType::STRUCT, 6);
    $xfer += $self->{o6}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_isPartitionMarkedForEvent_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_isPartitionMarkedForEvent_args->mk_accessors( qw( db_name tbl_name part_vals eventType ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_vals} = undef;
  $self->{eventType} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_vals}) {
      $self->{part_vals} = $vals->{part_vals};
    }
    if (defined $vals->{eventType}) {
      $self->{eventType} = $vals->{eventType};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_isPartitionMarkedForEvent_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size420 = 0;
          $self->{part_vals} = {};
          my $_ktype421 = 0;
          my $_vtype422 = 0;
          $xfer += $input->readMapBegin(\$_ktype421, \$_vtype422, \$_size420);
          for (my $_i424 = 0; $_i424 < $_size420; ++$_i424)
          {
            my $key425 = '';
            my $val426 = '';
            $xfer += $input->readString(\$key425);
            $xfer += $input->readString(\$val426);
            $self->{part_vals}->{$key425} = $val426;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{eventType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_isPartitionMarkedForEvent_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_vals}) {
    $xfer += $output->writeFieldBegin('part_vals', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{part_vals}}));
      {
        while( my ($kiter427,$viter428) = each %{$self->{part_vals}}) 
        {
          $xfer += $output->writeString($kiter427);
          $xfer += $output->writeString($viter428);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{eventType}) {
    $xfer += $output->writeFieldBegin('eventType', TType::I32, 4);
    $xfer += $output->writeI32($self->{eventType});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_isPartitionMarkedForEvent_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_isPartitionMarkedForEvent_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  $self->{o4} = undef;
  $self->{o5} = undef;
  $self->{o6} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
    if (defined $vals->{o4}) {
      $self->{o4} = $vals->{o4};
    }
    if (defined $vals->{o5}) {
      $self->{o5} = $vals->{o5};
    }
    if (defined $vals->{o6}) {
      $self->{o6} = $vals->{o6};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_isPartitionMarkedForEvent_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Impala::Protocol::HiveMetastore::UnknownDBException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o4} = new Impala::Protocol::HiveMetastore::UnknownTableException();
        $xfer += $self->{o4}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o5} = new Impala::Protocol::HiveMetastore::UnknownPartitionException();
        $xfer += $self->{o5}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o6} = new Impala::Protocol::HiveMetastore::InvalidPartitionException();
        $xfer += $self->{o6}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_isPartitionMarkedForEvent_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o4}) {
    $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
    $xfer += $self->{o4}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o5}) {
    $xfer += $output->writeFieldBegin('o5', TType::STRUCT, 5);
    $xfer += $self->{o5}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o6}) {
    $xfer += $output->writeFieldBegin('o6', TType::STRUCT, 6);
    $xfer += $self->{o6}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_index_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_index_args->mk_accessors( qw( new_index index_table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{new_index} = undef;
  $self->{index_table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{new_index}) {
      $self->{new_index} = $vals->{new_index};
    }
    if (defined $vals->{index_table}) {
      $self->{index_table} = $vals->{index_table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_add_index_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{new_index} = new Impala::Protocol::HiveMetastore::Index();
        $xfer += $self->{new_index}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{index_table} = new Impala::Protocol::HiveMetastore::Table();
        $xfer += $self->{index_table}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_index_args');
  if (defined $self->{new_index}) {
    $xfer += $output->writeFieldBegin('new_index', TType::STRUCT, 1);
    $xfer += $self->{new_index}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{index_table}) {
    $xfer += $output->writeFieldBegin('index_table', TType::STRUCT, 2);
    $xfer += $self->{index_table}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_index_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_index_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_add_index_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Impala::Protocol::HiveMetastore::Index();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::InvalidObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::AlreadyExistsException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_index_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_index_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_index_args->mk_accessors( qw( dbname base_tbl_name idx_name new_idx ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{dbname} = undef;
  $self->{base_tbl_name} = undef;
  $self->{idx_name} = undef;
  $self->{new_idx} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{dbname}) {
      $self->{dbname} = $vals->{dbname};
    }
    if (defined $vals->{base_tbl_name}) {
      $self->{base_tbl_name} = $vals->{base_tbl_name};
    }
    if (defined $vals->{idx_name}) {
      $self->{idx_name} = $vals->{idx_name};
    }
    if (defined $vals->{new_idx}) {
      $self->{new_idx} = $vals->{new_idx};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_alter_index_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dbname});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{base_tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{idx_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{new_idx} = new Impala::Protocol::HiveMetastore::Index();
        $xfer += $self->{new_idx}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_index_args');
  if (defined $self->{dbname}) {
    $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
    $xfer += $output->writeString($self->{dbname});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{base_tbl_name}) {
    $xfer += $output->writeFieldBegin('base_tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{base_tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{idx_name}) {
    $xfer += $output->writeFieldBegin('idx_name', TType::STRING, 3);
    $xfer += $output->writeString($self->{idx_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{new_idx}) {
    $xfer += $output->writeFieldBegin('new_idx', TType::STRUCT, 4);
    $xfer += $self->{new_idx}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_index_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_index_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_alter_index_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::InvalidOperationException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_index_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_index_by_name_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_index_by_name_args->mk_accessors( qw( db_name tbl_name index_name deleteData ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{index_name} = undef;
  $self->{deleteData} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{index_name}) {
      $self->{index_name} = $vals->{index_name};
    }
    if (defined $vals->{deleteData}) {
      $self->{deleteData} = $vals->{deleteData};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_index_by_name_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{index_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deleteData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_index_by_name_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{index_name}) {
    $xfer += $output->writeFieldBegin('index_name', TType::STRING, 3);
    $xfer += $output->writeString($self->{index_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleteData}) {
    $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{deleteData});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_index_by_name_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_index_by_name_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_index_by_name_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_index_by_name_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_index_by_name_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_index_by_name_args->mk_accessors( qw( db_name tbl_name index_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{index_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{index_name}) {
      $self->{index_name} = $vals->{index_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_index_by_name_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{index_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_index_by_name_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{index_name}) {
    $xfer += $output->writeFieldBegin('index_name', TType::STRING, 3);
    $xfer += $output->writeString($self->{index_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_index_by_name_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_index_by_name_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_index_by_name_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Impala::Protocol::HiveMetastore::Index();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_index_by_name_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_indexes_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_indexes_args->mk_accessors( qw( db_name tbl_name max_indexes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{max_indexes} = -1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{max_indexes}) {
      $self->{max_indexes} = $vals->{max_indexes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_indexes_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{max_indexes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_indexes_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_indexes}) {
    $xfer += $output->writeFieldBegin('max_indexes', TType::I16, 3);
    $xfer += $output->writeI16($self->{max_indexes});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_indexes_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_indexes_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_indexes_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size429 = 0;
          $self->{success} = [];
          my $_etype432 = 0;
          $xfer += $input->readListBegin(\$_etype432, \$_size429);
          for (my $_i433 = 0; $_i433 < $_size429; ++$_i433)
          {
            my $elem434 = undef;
            $elem434 = new Impala::Protocol::HiveMetastore::Index();
            $xfer += $elem434->read($input);
            push(@{$self->{success}},$elem434);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_indexes_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter435 (@{$self->{success}}) 
        {
          $xfer += ${iter435}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_index_names_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_index_names_args->mk_accessors( qw( db_name tbl_name max_indexes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{max_indexes} = -1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{max_indexes}) {
      $self->{max_indexes} = $vals->{max_indexes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_index_names_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{max_indexes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_index_names_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_indexes}) {
    $xfer += $output->writeFieldBegin('max_indexes', TType::I16, 3);
    $xfer += $output->writeI16($self->{max_indexes});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_index_names_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_index_names_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_index_names_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size436 = 0;
          $self->{success} = [];
          my $_etype439 = 0;
          $xfer += $input->readListBegin(\$_etype439, \$_size436);
          for (my $_i440 = 0; $_i440 < $_size436; ++$_i440)
          {
            my $elem441 = undef;
            $xfer += $input->readString(\$elem441);
            push(@{$self->{success}},$elem441);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_index_names_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter442 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter442);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 1);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_role_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_role_args->mk_accessors( qw( role ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{role} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{role}) {
      $self->{role} = $vals->{role};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_create_role_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{role} = new Impala::Protocol::HiveMetastore::Role();
        $xfer += $self->{role}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_role_args');
  if (defined $self->{role}) {
    $xfer += $output->writeFieldBegin('role', TType::STRUCT, 1);
    $xfer += $self->{role}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_role_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_role_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_create_role_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_role_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_role_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_role_args->mk_accessors( qw( role_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{role_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{role_name}) {
      $self->{role_name} = $vals->{role_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_role_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{role_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_role_args');
  if (defined $self->{role_name}) {
    $xfer += $output->writeFieldBegin('role_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{role_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_role_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_role_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_role_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_role_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_role_names_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_role_names_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_role_names_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_role_names_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_role_names_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_role_names_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size443 = 0;
          $self->{success} = [];
          my $_etype446 = 0;
          $xfer += $input->readListBegin(\$_etype446, \$_size443);
          for (my $_i447 = 0; $_i447 < $_size443; ++$_i447)
          {
            my $elem448 = undef;
            $xfer += $input->readString(\$elem448);
            push(@{$self->{success}},$elem448);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_role_names_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter449 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter449);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_grant_role_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_grant_role_args->mk_accessors( qw( role_name principal_name principal_type grantor grantorType grant_option ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{role_name} = undef;
  $self->{principal_name} = undef;
  $self->{principal_type} = undef;
  $self->{grantor} = undef;
  $self->{grantorType} = undef;
  $self->{grant_option} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{role_name}) {
      $self->{role_name} = $vals->{role_name};
    }
    if (defined $vals->{principal_name}) {
      $self->{principal_name} = $vals->{principal_name};
    }
    if (defined $vals->{principal_type}) {
      $self->{principal_type} = $vals->{principal_type};
    }
    if (defined $vals->{grantor}) {
      $self->{grantor} = $vals->{grantor};
    }
    if (defined $vals->{grantorType}) {
      $self->{grantorType} = $vals->{grantorType};
    }
    if (defined $vals->{grant_option}) {
      $self->{grant_option} = $vals->{grant_option};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_grant_role_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{role_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{principal_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{principal_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{grantor});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{grantorType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{grant_option});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_grant_role_args');
  if (defined $self->{role_name}) {
    $xfer += $output->writeFieldBegin('role_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{role_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{principal_name}) {
    $xfer += $output->writeFieldBegin('principal_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{principal_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{principal_type}) {
    $xfer += $output->writeFieldBegin('principal_type', TType::I32, 3);
    $xfer += $output->writeI32($self->{principal_type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{grantor}) {
    $xfer += $output->writeFieldBegin('grantor', TType::STRING, 4);
    $xfer += $output->writeString($self->{grantor});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{grantorType}) {
    $xfer += $output->writeFieldBegin('grantorType', TType::I32, 5);
    $xfer += $output->writeI32($self->{grantorType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{grant_option}) {
    $xfer += $output->writeFieldBegin('grant_option', TType::BOOL, 6);
    $xfer += $output->writeBool($self->{grant_option});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_grant_role_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_grant_role_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_grant_role_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_grant_role_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_revoke_role_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_revoke_role_args->mk_accessors( qw( role_name principal_name principal_type ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{role_name} = undef;
  $self->{principal_name} = undef;
  $self->{principal_type} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{role_name}) {
      $self->{role_name} = $vals->{role_name};
    }
    if (defined $vals->{principal_name}) {
      $self->{principal_name} = $vals->{principal_name};
    }
    if (defined $vals->{principal_type}) {
      $self->{principal_type} = $vals->{principal_type};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_revoke_role_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{role_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{principal_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{principal_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_revoke_role_args');
  if (defined $self->{role_name}) {
    $xfer += $output->writeFieldBegin('role_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{role_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{principal_name}) {
    $xfer += $output->writeFieldBegin('principal_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{principal_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{principal_type}) {
    $xfer += $output->writeFieldBegin('principal_type', TType::I32, 3);
    $xfer += $output->writeI32($self->{principal_type});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_revoke_role_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_revoke_role_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_revoke_role_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_revoke_role_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_list_roles_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_list_roles_args->mk_accessors( qw( principal_name principal_type ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{principal_name} = undef;
  $self->{principal_type} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{principal_name}) {
      $self->{principal_name} = $vals->{principal_name};
    }
    if (defined $vals->{principal_type}) {
      $self->{principal_type} = $vals->{principal_type};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_list_roles_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{principal_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{principal_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_list_roles_args');
  if (defined $self->{principal_name}) {
    $xfer += $output->writeFieldBegin('principal_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{principal_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{principal_type}) {
    $xfer += $output->writeFieldBegin('principal_type', TType::I32, 2);
    $xfer += $output->writeI32($self->{principal_type});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_list_roles_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_list_roles_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_list_roles_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size450 = 0;
          $self->{success} = [];
          my $_etype453 = 0;
          $xfer += $input->readListBegin(\$_etype453, \$_size450);
          for (my $_i454 = 0; $_i454 < $_size450; ++$_i454)
          {
            my $elem455 = undef;
            $elem455 = new Impala::Protocol::HiveMetastore::Role();
            $xfer += $elem455->read($input);
            push(@{$self->{success}},$elem455);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_list_roles_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter456 (@{$self->{success}}) 
        {
          $xfer += ${iter456}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_privilege_set_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_privilege_set_args->mk_accessors( qw( hiveObject user_name group_names ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{hiveObject} = undef;
  $self->{user_name} = undef;
  $self->{group_names} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{hiveObject}) {
      $self->{hiveObject} = $vals->{hiveObject};
    }
    if (defined $vals->{user_name}) {
      $self->{user_name} = $vals->{user_name};
    }
    if (defined $vals->{group_names}) {
      $self->{group_names} = $vals->{group_names};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_privilege_set_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{hiveObject} = new Impala::Protocol::HiveMetastore::HiveObjectRef();
        $xfer += $self->{hiveObject}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{user_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size457 = 0;
          $self->{group_names} = [];
          my $_etype460 = 0;
          $xfer += $input->readListBegin(\$_etype460, \$_size457);
          for (my $_i461 = 0; $_i461 < $_size457; ++$_i461)
          {
            my $elem462 = undef;
            $xfer += $input->readString(\$elem462);
            push(@{$self->{group_names}},$elem462);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_privilege_set_args');
  if (defined $self->{hiveObject}) {
    $xfer += $output->writeFieldBegin('hiveObject', TType::STRUCT, 1);
    $xfer += $self->{hiveObject}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{user_name}) {
    $xfer += $output->writeFieldBegin('user_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{user_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{group_names}) {
    $xfer += $output->writeFieldBegin('group_names', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{group_names}}));
      {
        foreach my $iter463 (@{$self->{group_names}}) 
        {
          $xfer += $output->writeString($iter463);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_privilege_set_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_privilege_set_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_privilege_set_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Impala::Protocol::HiveMetastore::PrincipalPrivilegeSet();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_privilege_set_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_list_privileges_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_list_privileges_args->mk_accessors( qw( principal_name principal_type hiveObject ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{principal_name} = undef;
  $self->{principal_type} = undef;
  $self->{hiveObject} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{principal_name}) {
      $self->{principal_name} = $vals->{principal_name};
    }
    if (defined $vals->{principal_type}) {
      $self->{principal_type} = $vals->{principal_type};
    }
    if (defined $vals->{hiveObject}) {
      $self->{hiveObject} = $vals->{hiveObject};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_list_privileges_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{principal_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{principal_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{hiveObject} = new Impala::Protocol::HiveMetastore::HiveObjectRef();
        $xfer += $self->{hiveObject}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_list_privileges_args');
  if (defined $self->{principal_name}) {
    $xfer += $output->writeFieldBegin('principal_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{principal_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{principal_type}) {
    $xfer += $output->writeFieldBegin('principal_type', TType::I32, 2);
    $xfer += $output->writeI32($self->{principal_type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{hiveObject}) {
    $xfer += $output->writeFieldBegin('hiveObject', TType::STRUCT, 3);
    $xfer += $self->{hiveObject}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_list_privileges_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_list_privileges_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_list_privileges_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size464 = 0;
          $self->{success} = [];
          my $_etype467 = 0;
          $xfer += $input->readListBegin(\$_etype467, \$_size464);
          for (my $_i468 = 0; $_i468 < $_size464; ++$_i468)
          {
            my $elem469 = undef;
            $elem469 = new Impala::Protocol::HiveMetastore::HiveObjectPrivilege();
            $xfer += $elem469->read($input);
            push(@{$self->{success}},$elem469);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_list_privileges_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter470 (@{$self->{success}}) 
        {
          $xfer += ${iter470}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_grant_privileges_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_grant_privileges_args->mk_accessors( qw( privileges ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{privileges} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{privileges}) {
      $self->{privileges} = $vals->{privileges};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_grant_privileges_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{privileges} = new Impala::Protocol::HiveMetastore::PrivilegeBag();
        $xfer += $self->{privileges}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_grant_privileges_args');
  if (defined $self->{privileges}) {
    $xfer += $output->writeFieldBegin('privileges', TType::STRUCT, 1);
    $xfer += $self->{privileges}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_grant_privileges_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_grant_privileges_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_grant_privileges_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_grant_privileges_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_revoke_privileges_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_revoke_privileges_args->mk_accessors( qw( privileges ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{privileges} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{privileges}) {
      $self->{privileges} = $vals->{privileges};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_revoke_privileges_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{privileges} = new Impala::Protocol::HiveMetastore::PrivilegeBag();
        $xfer += $self->{privileges}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_revoke_privileges_args');
  if (defined $self->{privileges}) {
    $xfer += $output->writeFieldBegin('privileges', TType::STRUCT, 1);
    $xfer += $self->{privileges}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_revoke_privileges_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_revoke_privileges_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_revoke_privileges_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_revoke_privileges_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_set_ugi_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_set_ugi_args->mk_accessors( qw( user_name group_names ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{user_name} = undef;
  $self->{group_names} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{user_name}) {
      $self->{user_name} = $vals->{user_name};
    }
    if (defined $vals->{group_names}) {
      $self->{group_names} = $vals->{group_names};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_set_ugi_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{user_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size471 = 0;
          $self->{group_names} = [];
          my $_etype474 = 0;
          $xfer += $input->readListBegin(\$_etype474, \$_size471);
          for (my $_i475 = 0; $_i475 < $_size471; ++$_i475)
          {
            my $elem476 = undef;
            $xfer += $input->readString(\$elem476);
            push(@{$self->{group_names}},$elem476);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_set_ugi_args');
  if (defined $self->{user_name}) {
    $xfer += $output->writeFieldBegin('user_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{user_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{group_names}) {
    $xfer += $output->writeFieldBegin('group_names', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{group_names}}));
      {
        foreach my $iter477 (@{$self->{group_names}}) 
        {
          $xfer += $output->writeString($iter477);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_set_ugi_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_set_ugi_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_set_ugi_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size478 = 0;
          $self->{success} = [];
          my $_etype481 = 0;
          $xfer += $input->readListBegin(\$_etype481, \$_size478);
          for (my $_i482 = 0; $_i482 < $_size478; ++$_i482)
          {
            my $elem483 = undef;
            $xfer += $input->readString(\$elem483);
            push(@{$self->{success}},$elem483);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_set_ugi_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter484 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter484);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_delegation_token_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_delegation_token_args->mk_accessors( qw( token_owner renewer_kerberos_principal_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{token_owner} = undef;
  $self->{renewer_kerberos_principal_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{token_owner}) {
      $self->{token_owner} = $vals->{token_owner};
    }
    if (defined $vals->{renewer_kerberos_principal_name}) {
      $self->{renewer_kerberos_principal_name} = $vals->{renewer_kerberos_principal_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_delegation_token_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{token_owner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{renewer_kerberos_principal_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_delegation_token_args');
  if (defined $self->{token_owner}) {
    $xfer += $output->writeFieldBegin('token_owner', TType::STRING, 1);
    $xfer += $output->writeString($self->{token_owner});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{renewer_kerberos_principal_name}) {
    $xfer += $output->writeFieldBegin('renewer_kerberos_principal_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{renewer_kerberos_principal_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_delegation_token_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_delegation_token_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_delegation_token_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_delegation_token_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_renew_delegation_token_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_renew_delegation_token_args->mk_accessors( qw( token_str_form ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{token_str_form} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{token_str_form}) {
      $self->{token_str_form} = $vals->{token_str_form};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_renew_delegation_token_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{token_str_form});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_renew_delegation_token_args');
  if (defined $self->{token_str_form}) {
    $xfer += $output->writeFieldBegin('token_str_form', TType::STRING, 1);
    $xfer += $output->writeString($self->{token_str_form});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_renew_delegation_token_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_renew_delegation_token_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_renew_delegation_token_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_renew_delegation_token_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_cancel_delegation_token_args;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_cancel_delegation_token_args->mk_accessors( qw( token_str_form ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{token_str_form} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{token_str_form}) {
      $self->{token_str_form} = $vals->{token_str_form};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_cancel_delegation_token_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{token_str_form});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_cancel_delegation_token_args');
  if (defined $self->{token_str_form}) {
    $xfer += $output->writeFieldBegin('token_str_form', TType::STRING, 1);
    $xfer += $output->writeString($self->{token_str_form});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastore_cancel_delegation_token_result;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ThriftHiveMetastore_cancel_delegation_token_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_cancel_delegation_token_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Impala::Protocol::HiveMetastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_cancel_delegation_token_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastoreIf;

use strict;
use base qw(Impala::Protocol::fb303::FacebookServiceIf);

sub create_database{
  my $self = shift;
  my $database = shift;

  die 'implement interface';
}

sub get_database{
  my $self = shift;
  my $name = shift;

  die 'implement interface';
}

sub drop_database{
  my $self = shift;
  my $name = shift;
  my $deleteData = shift;
  my $cascade = shift;

  die 'implement interface';
}

sub get_databases{
  my $self = shift;
  my $pattern = shift;

  die 'implement interface';
}

sub get_all_databases{
  my $self = shift;

  die 'implement interface';
}

sub alter_database{
  my $self = shift;
  my $dbname = shift;
  my $db = shift;

  die 'implement interface';
}

sub get_type{
  my $self = shift;
  my $name = shift;

  die 'implement interface';
}

sub create_type{
  my $self = shift;
  my $type = shift;

  die 'implement interface';
}

sub drop_type{
  my $self = shift;
  my $type = shift;

  die 'implement interface';
}

sub get_type_all{
  my $self = shift;
  my $name = shift;

  die 'implement interface';
}

sub get_fields{
  my $self = shift;
  my $db_name = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub get_schema{
  my $self = shift;
  my $db_name = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub create_table{
  my $self = shift;
  my $tbl = shift;

  die 'implement interface';
}

sub create_table_with_environment_context{
  my $self = shift;
  my $tbl = shift;
  my $environment_context = shift;

  die 'implement interface';
}

sub drop_table{
  my $self = shift;
  my $dbname = shift;
  my $name = shift;
  my $deleteData = shift;

  die 'implement interface';
}

sub get_tables{
  my $self = shift;
  my $db_name = shift;
  my $pattern = shift;

  die 'implement interface';
}

sub get_all_tables{
  my $self = shift;
  my $db_name = shift;

  die 'implement interface';
}

sub get_table{
  my $self = shift;
  my $dbname = shift;
  my $tbl_name = shift;

  die 'implement interface';
}

sub get_table_objects_by_name{
  my $self = shift;
  my $dbname = shift;
  my $tbl_names = shift;

  die 'implement interface';
}

sub get_table_names_by_filter{
  my $self = shift;
  my $dbname = shift;
  my $filter = shift;
  my $max_tables = shift;

  die 'implement interface';
}

sub alter_table{
  my $self = shift;
  my $dbname = shift;
  my $tbl_name = shift;
  my $new_tbl = shift;

  die 'implement interface';
}

sub alter_table_with_environment_context{
  my $self = shift;
  my $dbname = shift;
  my $tbl_name = shift;
  my $new_tbl = shift;
  my $environment_context = shift;

  die 'implement interface';
}

sub add_partition{
  my $self = shift;
  my $new_part = shift;

  die 'implement interface';
}

sub add_partition_with_environment_context{
  my $self = shift;
  my $new_part = shift;
  my $environment_context = shift;

  die 'implement interface';
}

sub add_partitions{
  my $self = shift;
  my $new_parts = shift;

  die 'implement interface';
}

sub append_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;

  die 'implement interface';
}

sub append_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;

  die 'implement interface';
}

sub drop_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $deleteData = shift;

  die 'implement interface';
}

sub drop_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;
  my $deleteData = shift;

  die 'implement interface';
}

sub get_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;

  die 'implement interface';
}

sub get_partition_with_auth{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $user_name = shift;
  my $group_names = shift;

  die 'implement interface';
}

sub get_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;

  die 'implement interface';
}

sub get_partitions{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_parts = shift;

  die 'implement interface';
}

sub get_partitions_with_auth{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_parts = shift;
  my $user_name = shift;
  my $group_names = shift;

  die 'implement interface';
}

sub get_partition_names{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_parts = shift;

  die 'implement interface';
}

sub get_partitions_ps{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $max_parts = shift;

  die 'implement interface';
}

sub get_partitions_ps_with_auth{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $max_parts = shift;
  my $user_name = shift;
  my $group_names = shift;

  die 'implement interface';
}

sub get_partition_names_ps{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $max_parts = shift;

  die 'implement interface';
}

sub get_partitions_by_filter{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $filter = shift;
  my $max_parts = shift;

  die 'implement interface';
}

sub get_partitions_by_names{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $names = shift;

  die 'implement interface';
}

sub alter_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $new_part = shift;

  die 'implement interface';
}

sub alter_partition_with_environment_context{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $new_part = shift;
  my $environment_context = shift;

  die 'implement interface';
}

sub rename_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $new_part = shift;

  die 'implement interface';
}

sub get_config_value{
  my $self = shift;
  my $name = shift;
  my $defaultValue = shift;

  die 'implement interface';
}

sub partition_name_to_vals{
  my $self = shift;
  my $part_name = shift;

  die 'implement interface';
}

sub partition_name_to_spec{
  my $self = shift;
  my $part_name = shift;

  die 'implement interface';
}

sub markPartitionForEvent{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $eventType = shift;

  die 'implement interface';
}

sub isPartitionMarkedForEvent{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $eventType = shift;

  die 'implement interface';
}

sub add_index{
  my $self = shift;
  my $new_index = shift;
  my $index_table = shift;

  die 'implement interface';
}

sub alter_index{
  my $self = shift;
  my $dbname = shift;
  my $base_tbl_name = shift;
  my $idx_name = shift;
  my $new_idx = shift;

  die 'implement interface';
}

sub drop_index_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $index_name = shift;
  my $deleteData = shift;

  die 'implement interface';
}

sub get_index_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $index_name = shift;

  die 'implement interface';
}

sub get_indexes{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_indexes = shift;

  die 'implement interface';
}

sub get_index_names{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_indexes = shift;

  die 'implement interface';
}

sub create_role{
  my $self = shift;
  my $role = shift;

  die 'implement interface';
}

sub drop_role{
  my $self = shift;
  my $role_name = shift;

  die 'implement interface';
}

sub get_role_names{
  my $self = shift;

  die 'implement interface';
}

sub grant_role{
  my $self = shift;
  my $role_name = shift;
  my $principal_name = shift;
  my $principal_type = shift;
  my $grantor = shift;
  my $grantorType = shift;
  my $grant_option = shift;

  die 'implement interface';
}

sub revoke_role{
  my $self = shift;
  my $role_name = shift;
  my $principal_name = shift;
  my $principal_type = shift;

  die 'implement interface';
}

sub list_roles{
  my $self = shift;
  my $principal_name = shift;
  my $principal_type = shift;

  die 'implement interface';
}

sub get_privilege_set{
  my $self = shift;
  my $hiveObject = shift;
  my $user_name = shift;
  my $group_names = shift;

  die 'implement interface';
}

sub list_privileges{
  my $self = shift;
  my $principal_name = shift;
  my $principal_type = shift;
  my $hiveObject = shift;

  die 'implement interface';
}

sub grant_privileges{
  my $self = shift;
  my $privileges = shift;

  die 'implement interface';
}

sub revoke_privileges{
  my $self = shift;
  my $privileges = shift;

  die 'implement interface';
}

sub set_ugi{
  my $self = shift;
  my $user_name = shift;
  my $group_names = shift;

  die 'implement interface';
}

sub get_delegation_token{
  my $self = shift;
  my $token_owner = shift;
  my $renewer_kerberos_principal_name = shift;

  die 'implement interface';
}

sub renew_delegation_token{
  my $self = shift;
  my $token_str_form = shift;

  die 'implement interface';
}

sub cancel_delegation_token{
  my $self = shift;
  my $token_str_form = shift;

  die 'implement interface';
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastoreRest;

use strict;
use base qw(Impala::Protocol::fb303::FacebookServiceRest);

sub create_database{
  my ($self, $request) = @_;

  my $database = ($request->{'database'}) ? $request->{'database'} : undef;
  return $self->{impl}->create_database($database);
}

sub get_database{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->get_database($name);
}

sub drop_database{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $deleteData = ($request->{'deleteData'}) ? $request->{'deleteData'} : undef;
  my $cascade = ($request->{'cascade'}) ? $request->{'cascade'} : undef;
  return $self->{impl}->drop_database($name, $deleteData, $cascade);
}

sub get_databases{
  my ($self, $request) = @_;

  my $pattern = ($request->{'pattern'}) ? $request->{'pattern'} : undef;
  return $self->{impl}->get_databases($pattern);
}

sub get_all_databases{
  my ($self, $request) = @_;

  return $self->{impl}->get_all_databases();
}

sub alter_database{
  my ($self, $request) = @_;

  my $dbname = ($request->{'dbname'}) ? $request->{'dbname'} : undef;
  my $db = ($request->{'db'}) ? $request->{'db'} : undef;
  return $self->{impl}->alter_database($dbname, $db);
}

sub get_type{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->get_type($name);
}

sub create_type{
  my ($self, $request) = @_;

  my $type = ($request->{'type'}) ? $request->{'type'} : undef;
  return $self->{impl}->create_type($type);
}

sub drop_type{
  my ($self, $request) = @_;

  my $type = ($request->{'type'}) ? $request->{'type'} : undef;
  return $self->{impl}->drop_type($type);
}

sub get_type_all{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->get_type_all($name);
}

sub get_fields{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->get_fields($db_name, $table_name);
}

sub get_schema{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->get_schema($db_name, $table_name);
}

sub create_table{
  my ($self, $request) = @_;

  my $tbl = ($request->{'tbl'}) ? $request->{'tbl'} : undef;
  return $self->{impl}->create_table($tbl);
}

sub create_table_with_environment_context{
  my ($self, $request) = @_;

  my $tbl = ($request->{'tbl'}) ? $request->{'tbl'} : undef;
  my $environment_context = ($request->{'environment_context'}) ? $request->{'environment_context'} : undef;
  return $self->{impl}->create_table_with_environment_context($tbl, $environment_context);
}

sub drop_table{
  my ($self, $request) = @_;

  my $dbname = ($request->{'dbname'}) ? $request->{'dbname'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $deleteData = ($request->{'deleteData'}) ? $request->{'deleteData'} : undef;
  return $self->{impl}->drop_table($dbname, $name, $deleteData);
}

sub get_tables{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $pattern = ($request->{'pattern'}) ? $request->{'pattern'} : undef;
  return $self->{impl}->get_tables($db_name, $pattern);
}

sub get_all_tables{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  return $self->{impl}->get_all_tables($db_name);
}

sub get_table{
  my ($self, $request) = @_;

  my $dbname = ($request->{'dbname'}) ? $request->{'dbname'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  return $self->{impl}->get_table($dbname, $tbl_name);
}

sub get_table_objects_by_name{
  my ($self, $request) = @_;

  my $dbname = ($request->{'dbname'}) ? $request->{'dbname'} : undef;
  my $tbl_names = ($request->{'tbl_names'}) ? $request->{'tbl_names'} : undef;
  return $self->{impl}->get_table_objects_by_name($dbname, $tbl_names);
}

sub get_table_names_by_filter{
  my ($self, $request) = @_;

  my $dbname = ($request->{'dbname'}) ? $request->{'dbname'} : undef;
  my $filter = ($request->{'filter'}) ? $request->{'filter'} : undef;
  my $max_tables = ($request->{'max_tables'}) ? $request->{'max_tables'} : undef;
  return $self->{impl}->get_table_names_by_filter($dbname, $filter, $max_tables);
}

sub alter_table{
  my ($self, $request) = @_;

  my $dbname = ($request->{'dbname'}) ? $request->{'dbname'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $new_tbl = ($request->{'new_tbl'}) ? $request->{'new_tbl'} : undef;
  return $self->{impl}->alter_table($dbname, $tbl_name, $new_tbl);
}

sub alter_table_with_environment_context{
  my ($self, $request) = @_;

  my $dbname = ($request->{'dbname'}) ? $request->{'dbname'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $new_tbl = ($request->{'new_tbl'}) ? $request->{'new_tbl'} : undef;
  my $environment_context = ($request->{'environment_context'}) ? $request->{'environment_context'} : undef;
  return $self->{impl}->alter_table_with_environment_context($dbname, $tbl_name, $new_tbl, $environment_context);
}

sub add_partition{
  my ($self, $request) = @_;

  my $new_part = ($request->{'new_part'}) ? $request->{'new_part'} : undef;
  return $self->{impl}->add_partition($new_part);
}

sub add_partition_with_environment_context{
  my ($self, $request) = @_;

  my $new_part = ($request->{'new_part'}) ? $request->{'new_part'} : undef;
  my $environment_context = ($request->{'environment_context'}) ? $request->{'environment_context'} : undef;
  return $self->{impl}->add_partition_with_environment_context($new_part, $environment_context);
}

sub add_partitions{
  my ($self, $request) = @_;

  my $new_parts = ($request->{'new_parts'}) ? $request->{'new_parts'} : undef;
  return $self->{impl}->add_partitions($new_parts);
}

sub append_partition{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_vals = ($request->{'part_vals'}) ? $request->{'part_vals'} : undef;
  return $self->{impl}->append_partition($db_name, $tbl_name, $part_vals);
}

sub append_partition_by_name{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_name = ($request->{'part_name'}) ? $request->{'part_name'} : undef;
  return $self->{impl}->append_partition_by_name($db_name, $tbl_name, $part_name);
}

sub drop_partition{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_vals = ($request->{'part_vals'}) ? $request->{'part_vals'} : undef;
  my $deleteData = ($request->{'deleteData'}) ? $request->{'deleteData'} : undef;
  return $self->{impl}->drop_partition($db_name, $tbl_name, $part_vals, $deleteData);
}

sub drop_partition_by_name{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_name = ($request->{'part_name'}) ? $request->{'part_name'} : undef;
  my $deleteData = ($request->{'deleteData'}) ? $request->{'deleteData'} : undef;
  return $self->{impl}->drop_partition_by_name($db_name, $tbl_name, $part_name, $deleteData);
}

sub get_partition{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_vals = ($request->{'part_vals'}) ? $request->{'part_vals'} : undef;
  return $self->{impl}->get_partition($db_name, $tbl_name, $part_vals);
}

sub get_partition_with_auth{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_vals = ($request->{'part_vals'}) ? $request->{'part_vals'} : undef;
  my $user_name = ($request->{'user_name'}) ? $request->{'user_name'} : undef;
  my $group_names = ($request->{'group_names'}) ? $request->{'group_names'} : undef;
  return $self->{impl}->get_partition_with_auth($db_name, $tbl_name, $part_vals, $user_name, $group_names);
}

sub get_partition_by_name{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_name = ($request->{'part_name'}) ? $request->{'part_name'} : undef;
  return $self->{impl}->get_partition_by_name($db_name, $tbl_name, $part_name);
}

sub get_partitions{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $max_parts = ($request->{'max_parts'}) ? $request->{'max_parts'} : undef;
  return $self->{impl}->get_partitions($db_name, $tbl_name, $max_parts);
}

sub get_partitions_with_auth{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $max_parts = ($request->{'max_parts'}) ? $request->{'max_parts'} : undef;
  my $user_name = ($request->{'user_name'}) ? $request->{'user_name'} : undef;
  my $group_names = ($request->{'group_names'}) ? $request->{'group_names'} : undef;
  return $self->{impl}->get_partitions_with_auth($db_name, $tbl_name, $max_parts, $user_name, $group_names);
}

sub get_partition_names{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $max_parts = ($request->{'max_parts'}) ? $request->{'max_parts'} : undef;
  return $self->{impl}->get_partition_names($db_name, $tbl_name, $max_parts);
}

sub get_partitions_ps{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_vals = ($request->{'part_vals'}) ? $request->{'part_vals'} : undef;
  my $max_parts = ($request->{'max_parts'}) ? $request->{'max_parts'} : undef;
  return $self->{impl}->get_partitions_ps($db_name, $tbl_name, $part_vals, $max_parts);
}

sub get_partitions_ps_with_auth{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_vals = ($request->{'part_vals'}) ? $request->{'part_vals'} : undef;
  my $max_parts = ($request->{'max_parts'}) ? $request->{'max_parts'} : undef;
  my $user_name = ($request->{'user_name'}) ? $request->{'user_name'} : undef;
  my $group_names = ($request->{'group_names'}) ? $request->{'group_names'} : undef;
  return $self->{impl}->get_partitions_ps_with_auth($db_name, $tbl_name, $part_vals, $max_parts, $user_name, $group_names);
}

sub get_partition_names_ps{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_vals = ($request->{'part_vals'}) ? $request->{'part_vals'} : undef;
  my $max_parts = ($request->{'max_parts'}) ? $request->{'max_parts'} : undef;
  return $self->{impl}->get_partition_names_ps($db_name, $tbl_name, $part_vals, $max_parts);
}

sub get_partitions_by_filter{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $filter = ($request->{'filter'}) ? $request->{'filter'} : undef;
  my $max_parts = ($request->{'max_parts'}) ? $request->{'max_parts'} : undef;
  return $self->{impl}->get_partitions_by_filter($db_name, $tbl_name, $filter, $max_parts);
}

sub get_partitions_by_names{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $names = ($request->{'names'}) ? $request->{'names'} : undef;
  return $self->{impl}->get_partitions_by_names($db_name, $tbl_name, $names);
}

sub alter_partition{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $new_part = ($request->{'new_part'}) ? $request->{'new_part'} : undef;
  return $self->{impl}->alter_partition($db_name, $tbl_name, $new_part);
}

sub alter_partition_with_environment_context{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $new_part = ($request->{'new_part'}) ? $request->{'new_part'} : undef;
  my $environment_context = ($request->{'environment_context'}) ? $request->{'environment_context'} : undef;
  return $self->{impl}->alter_partition_with_environment_context($db_name, $tbl_name, $new_part, $environment_context);
}

sub rename_partition{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_vals = ($request->{'part_vals'}) ? $request->{'part_vals'} : undef;
  my $new_part = ($request->{'new_part'}) ? $request->{'new_part'} : undef;
  return $self->{impl}->rename_partition($db_name, $tbl_name, $part_vals, $new_part);
}

sub get_config_value{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $defaultValue = ($request->{'defaultValue'}) ? $request->{'defaultValue'} : undef;
  return $self->{impl}->get_config_value($name, $defaultValue);
}

sub partition_name_to_vals{
  my ($self, $request) = @_;

  my $part_name = ($request->{'part_name'}) ? $request->{'part_name'} : undef;
  return $self->{impl}->partition_name_to_vals($part_name);
}

sub partition_name_to_spec{
  my ($self, $request) = @_;

  my $part_name = ($request->{'part_name'}) ? $request->{'part_name'} : undef;
  return $self->{impl}->partition_name_to_spec($part_name);
}

sub markPartitionForEvent{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_vals = ($request->{'part_vals'}) ? $request->{'part_vals'} : undef;
  my $eventType = ($request->{'eventType'}) ? $request->{'eventType'} : undef;
  return $self->{impl}->markPartitionForEvent($db_name, $tbl_name, $part_vals, $eventType);
}

sub isPartitionMarkedForEvent{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_vals = ($request->{'part_vals'}) ? $request->{'part_vals'} : undef;
  my $eventType = ($request->{'eventType'}) ? $request->{'eventType'} : undef;
  return $self->{impl}->isPartitionMarkedForEvent($db_name, $tbl_name, $part_vals, $eventType);
}

sub add_index{
  my ($self, $request) = @_;

  my $new_index = ($request->{'new_index'}) ? $request->{'new_index'} : undef;
  my $index_table = ($request->{'index_table'}) ? $request->{'index_table'} : undef;
  return $self->{impl}->add_index($new_index, $index_table);
}

sub alter_index{
  my ($self, $request) = @_;

  my $dbname = ($request->{'dbname'}) ? $request->{'dbname'} : undef;
  my $base_tbl_name = ($request->{'base_tbl_name'}) ? $request->{'base_tbl_name'} : undef;
  my $idx_name = ($request->{'idx_name'}) ? $request->{'idx_name'} : undef;
  my $new_idx = ($request->{'new_idx'}) ? $request->{'new_idx'} : undef;
  return $self->{impl}->alter_index($dbname, $base_tbl_name, $idx_name, $new_idx);
}

sub drop_index_by_name{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $index_name = ($request->{'index_name'}) ? $request->{'index_name'} : undef;
  my $deleteData = ($request->{'deleteData'}) ? $request->{'deleteData'} : undef;
  return $self->{impl}->drop_index_by_name($db_name, $tbl_name, $index_name, $deleteData);
}

sub get_index_by_name{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $index_name = ($request->{'index_name'}) ? $request->{'index_name'} : undef;
  return $self->{impl}->get_index_by_name($db_name, $tbl_name, $index_name);
}

sub get_indexes{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $max_indexes = ($request->{'max_indexes'}) ? $request->{'max_indexes'} : undef;
  return $self->{impl}->get_indexes($db_name, $tbl_name, $max_indexes);
}

sub get_index_names{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $max_indexes = ($request->{'max_indexes'}) ? $request->{'max_indexes'} : undef;
  return $self->{impl}->get_index_names($db_name, $tbl_name, $max_indexes);
}

sub create_role{
  my ($self, $request) = @_;

  my $role = ($request->{'role'}) ? $request->{'role'} : undef;
  return $self->{impl}->create_role($role);
}

sub drop_role{
  my ($self, $request) = @_;

  my $role_name = ($request->{'role_name'}) ? $request->{'role_name'} : undef;
  return $self->{impl}->drop_role($role_name);
}

sub get_role_names{
  my ($self, $request) = @_;

  return $self->{impl}->get_role_names();
}

sub grant_role{
  my ($self, $request) = @_;

  my $role_name = ($request->{'role_name'}) ? $request->{'role_name'} : undef;
  my $principal_name = ($request->{'principal_name'}) ? $request->{'principal_name'} : undef;
  my $principal_type = ($request->{'principal_type'}) ? $request->{'principal_type'} : undef;
  my $grantor = ($request->{'grantor'}) ? $request->{'grantor'} : undef;
  my $grantorType = ($request->{'grantorType'}) ? $request->{'grantorType'} : undef;
  my $grant_option = ($request->{'grant_option'}) ? $request->{'grant_option'} : undef;
  return $self->{impl}->grant_role($role_name, $principal_name, $principal_type, $grantor, $grantorType, $grant_option);
}

sub revoke_role{
  my ($self, $request) = @_;

  my $role_name = ($request->{'role_name'}) ? $request->{'role_name'} : undef;
  my $principal_name = ($request->{'principal_name'}) ? $request->{'principal_name'} : undef;
  my $principal_type = ($request->{'principal_type'}) ? $request->{'principal_type'} : undef;
  return $self->{impl}->revoke_role($role_name, $principal_name, $principal_type);
}

sub list_roles{
  my ($self, $request) = @_;

  my $principal_name = ($request->{'principal_name'}) ? $request->{'principal_name'} : undef;
  my $principal_type = ($request->{'principal_type'}) ? $request->{'principal_type'} : undef;
  return $self->{impl}->list_roles($principal_name, $principal_type);
}

sub get_privilege_set{
  my ($self, $request) = @_;

  my $hiveObject = ($request->{'hiveObject'}) ? $request->{'hiveObject'} : undef;
  my $user_name = ($request->{'user_name'}) ? $request->{'user_name'} : undef;
  my $group_names = ($request->{'group_names'}) ? $request->{'group_names'} : undef;
  return $self->{impl}->get_privilege_set($hiveObject, $user_name, $group_names);
}

sub list_privileges{
  my ($self, $request) = @_;

  my $principal_name = ($request->{'principal_name'}) ? $request->{'principal_name'} : undef;
  my $principal_type = ($request->{'principal_type'}) ? $request->{'principal_type'} : undef;
  my $hiveObject = ($request->{'hiveObject'}) ? $request->{'hiveObject'} : undef;
  return $self->{impl}->list_privileges($principal_name, $principal_type, $hiveObject);
}

sub grant_privileges{
  my ($self, $request) = @_;

  my $privileges = ($request->{'privileges'}) ? $request->{'privileges'} : undef;
  return $self->{impl}->grant_privileges($privileges);
}

sub revoke_privileges{
  my ($self, $request) = @_;

  my $privileges = ($request->{'privileges'}) ? $request->{'privileges'} : undef;
  return $self->{impl}->revoke_privileges($privileges);
}

sub set_ugi{
  my ($self, $request) = @_;

  my $user_name = ($request->{'user_name'}) ? $request->{'user_name'} : undef;
  my $group_names = ($request->{'group_names'}) ? $request->{'group_names'} : undef;
  return $self->{impl}->set_ugi($user_name, $group_names);
}

sub get_delegation_token{
  my ($self, $request) = @_;

  my $token_owner = ($request->{'token_owner'}) ? $request->{'token_owner'} : undef;
  my $renewer_kerberos_principal_name = ($request->{'renewer_kerberos_principal_name'}) ? $request->{'renewer_kerberos_principal_name'} : undef;
  return $self->{impl}->get_delegation_token($token_owner, $renewer_kerberos_principal_name);
}

sub renew_delegation_token{
  my ($self, $request) = @_;

  my $token_str_form = ($request->{'token_str_form'}) ? $request->{'token_str_form'} : undef;
  return $self->{impl}->renew_delegation_token($token_str_form);
}

sub cancel_delegation_token{
  my ($self, $request) = @_;

  my $token_str_form = ($request->{'token_str_form'}) ? $request->{'token_str_form'} : undef;
  return $self->{impl}->cancel_delegation_token($token_str_form);
}

package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastoreClient;

use base qw(Impala::Protocol::fb303::FacebookServiceClient);
use base qw(Impala::Protocol::HiveMetastore::ThriftHiveMetastoreIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self = $classname->SUPER::new($input, $output);
  return bless($self,$classname);
}

sub create_database{
  my $self = shift;
  my $database = shift;

    $self->send_create_database($database);
  $self->recv_create_database();
}

sub send_create_database{
  my $self = shift;
  my $database = shift;

  $self->{output}->writeMessageBegin('create_database', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_database_args();
  $args->{database} = $database;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_create_database{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_database_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  return;
}
sub get_database{
  my $self = shift;
  my $name = shift;

    $self->send_get_database($name);
  return $self->recv_get_database();
}

sub send_get_database{
  my $self = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('get_database', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_database_args();
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_database{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_database_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_database failed: unknown result";
}
sub drop_database{
  my $self = shift;
  my $name = shift;
  my $deleteData = shift;
  my $cascade = shift;

    $self->send_drop_database($name, $deleteData, $cascade);
  $self->recv_drop_database();
}

sub send_drop_database{
  my $self = shift;
  my $name = shift;
  my $deleteData = shift;
  my $cascade = shift;

  $self->{output}->writeMessageBegin('drop_database', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_database_args();
  $args->{name} = $name;
  $args->{deleteData} = $deleteData;
  $args->{cascade} = $cascade;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_database{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_database_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  return;
}
sub get_databases{
  my $self = shift;
  my $pattern = shift;

    $self->send_get_databases($pattern);
  return $self->recv_get_databases();
}

sub send_get_databases{
  my $self = shift;
  my $pattern = shift;

  $self->{output}->writeMessageBegin('get_databases', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_databases_args();
  $args->{pattern} = $pattern;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_databases{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_databases_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_databases failed: unknown result";
}
sub get_all_databases{
  my $self = shift;

    $self->send_get_all_databases();
  return $self->recv_get_all_databases();
}

sub send_get_all_databases{
  my $self = shift;

  $self->{output}->writeMessageBegin('get_all_databases', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_all_databases_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_all_databases{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_all_databases_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_all_databases failed: unknown result";
}
sub alter_database{
  my $self = shift;
  my $dbname = shift;
  my $db = shift;

    $self->send_alter_database($dbname, $db);
  $self->recv_alter_database();
}

sub send_alter_database{
  my $self = shift;
  my $dbname = shift;
  my $db = shift;

  $self->{output}->writeMessageBegin('alter_database', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_database_args();
  $args->{dbname} = $dbname;
  $args->{db} = $db;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_alter_database{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_database_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  return;
}
sub get_type{
  my $self = shift;
  my $name = shift;

    $self->send_get_type($name);
  return $self->recv_get_type();
}

sub send_get_type{
  my $self = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('get_type', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_type_args();
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_type{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_type_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_type failed: unknown result";
}
sub create_type{
  my $self = shift;
  my $type = shift;

    $self->send_create_type($type);
  return $self->recv_create_type();
}

sub send_create_type{
  my $self = shift;
  my $type = shift;

  $self->{output}->writeMessageBegin('create_type', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_type_args();
  $args->{type} = $type;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_create_type{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_type_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  die "create_type failed: unknown result";
}
sub drop_type{
  my $self = shift;
  my $type = shift;

    $self->send_drop_type($type);
  return $self->recv_drop_type();
}

sub send_drop_type{
  my $self = shift;
  my $type = shift;

  $self->{output}->writeMessageBegin('drop_type', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_type_args();
  $args->{type} = $type;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_type{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_type_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "drop_type failed: unknown result";
}
sub get_type_all{
  my $self = shift;
  my $name = shift;

    $self->send_get_type_all($name);
  return $self->recv_get_type_all();
}

sub send_get_type_all{
  my $self = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('get_type_all', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_type_all_args();
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_type_all{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_type_all_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_type_all failed: unknown result";
}
sub get_fields{
  my $self = shift;
  my $db_name = shift;
  my $table_name = shift;

    $self->send_get_fields($db_name, $table_name);
  return $self->recv_get_fields();
}

sub send_get_fields{
  my $self = shift;
  my $db_name = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('get_fields', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_fields_args();
  $args->{db_name} = $db_name;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_fields{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_fields_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  die "get_fields failed: unknown result";
}
sub get_schema{
  my $self = shift;
  my $db_name = shift;
  my $table_name = shift;

    $self->send_get_schema($db_name, $table_name);
  return $self->recv_get_schema();
}

sub send_get_schema{
  my $self = shift;
  my $db_name = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('get_schema', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_schema_args();
  $args->{db_name} = $db_name;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_schema{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_schema_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  die "get_schema failed: unknown result";
}
sub create_table{
  my $self = shift;
  my $tbl = shift;

    $self->send_create_table($tbl);
  $self->recv_create_table();
}

sub send_create_table{
  my $self = shift;
  my $tbl = shift;

  $self->{output}->writeMessageBegin('create_table', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_table_args();
  $args->{tbl} = $tbl;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_create_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  if (defined $result->{o4}) {
    die $result->{o4};
  }
  return;
}
sub create_table_with_environment_context{
  my $self = shift;
  my $tbl = shift;
  my $environment_context = shift;

    $self->send_create_table_with_environment_context($tbl, $environment_context);
  $self->recv_create_table_with_environment_context();
}

sub send_create_table_with_environment_context{
  my $self = shift;
  my $tbl = shift;
  my $environment_context = shift;

  $self->{output}->writeMessageBegin('create_table_with_environment_context', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_table_with_environment_context_args();
  $args->{tbl} = $tbl;
  $args->{environment_context} = $environment_context;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_create_table_with_environment_context{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_table_with_environment_context_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  if (defined $result->{o4}) {
    die $result->{o4};
  }
  return;
}
sub drop_table{
  my $self = shift;
  my $dbname = shift;
  my $name = shift;
  my $deleteData = shift;

    $self->send_drop_table($dbname, $name, $deleteData);
  $self->recv_drop_table();
}

sub send_drop_table{
  my $self = shift;
  my $dbname = shift;
  my $name = shift;
  my $deleteData = shift;

  $self->{output}->writeMessageBegin('drop_table', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_table_args();
  $args->{dbname} = $dbname;
  $args->{name} = $name;
  $args->{deleteData} = $deleteData;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  return;
}
sub get_tables{
  my $self = shift;
  my $db_name = shift;
  my $pattern = shift;

    $self->send_get_tables($db_name, $pattern);
  return $self->recv_get_tables();
}

sub send_get_tables{
  my $self = shift;
  my $db_name = shift;
  my $pattern = shift;

  $self->{output}->writeMessageBegin('get_tables', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_tables_args();
  $args->{db_name} = $db_name;
  $args->{pattern} = $pattern;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_tables{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_tables_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_tables failed: unknown result";
}
sub get_all_tables{
  my $self = shift;
  my $db_name = shift;

    $self->send_get_all_tables($db_name);
  return $self->recv_get_all_tables();
}

sub send_get_all_tables{
  my $self = shift;
  my $db_name = shift;

  $self->{output}->writeMessageBegin('get_all_tables', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_all_tables_args();
  $args->{db_name} = $db_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_all_tables{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_all_tables_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_all_tables failed: unknown result";
}
sub get_table{
  my $self = shift;
  my $dbname = shift;
  my $tbl_name = shift;

    $self->send_get_table($dbname, $tbl_name);
  return $self->recv_get_table();
}

sub send_get_table{
  my $self = shift;
  my $dbname = shift;
  my $tbl_name = shift;

  $self->{output}->writeMessageBegin('get_table', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_table_args();
  $args->{dbname} = $dbname;
  $args->{tbl_name} = $tbl_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_table failed: unknown result";
}
sub get_table_objects_by_name{
  my $self = shift;
  my $dbname = shift;
  my $tbl_names = shift;

    $self->send_get_table_objects_by_name($dbname, $tbl_names);
  return $self->recv_get_table_objects_by_name();
}

sub send_get_table_objects_by_name{
  my $self = shift;
  my $dbname = shift;
  my $tbl_names = shift;

  $self->{output}->writeMessageBegin('get_table_objects_by_name', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_table_objects_by_name_args();
  $args->{dbname} = $dbname;
  $args->{tbl_names} = $tbl_names;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_table_objects_by_name{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_table_objects_by_name_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  die "get_table_objects_by_name failed: unknown result";
}
sub get_table_names_by_filter{
  my $self = shift;
  my $dbname = shift;
  my $filter = shift;
  my $max_tables = shift;

    $self->send_get_table_names_by_filter($dbname, $filter, $max_tables);
  return $self->recv_get_table_names_by_filter();
}

sub send_get_table_names_by_filter{
  my $self = shift;
  my $dbname = shift;
  my $filter = shift;
  my $max_tables = shift;

  $self->{output}->writeMessageBegin('get_table_names_by_filter', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_table_names_by_filter_args();
  $args->{dbname} = $dbname;
  $args->{filter} = $filter;
  $args->{max_tables} = $max_tables;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_table_names_by_filter{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_table_names_by_filter_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  die "get_table_names_by_filter failed: unknown result";
}
sub alter_table{
  my $self = shift;
  my $dbname = shift;
  my $tbl_name = shift;
  my $new_tbl = shift;

    $self->send_alter_table($dbname, $tbl_name, $new_tbl);
  $self->recv_alter_table();
}

sub send_alter_table{
  my $self = shift;
  my $dbname = shift;
  my $tbl_name = shift;
  my $new_tbl = shift;

  $self->{output}->writeMessageBegin('alter_table', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_table_args();
  $args->{dbname} = $dbname;
  $args->{tbl_name} = $tbl_name;
  $args->{new_tbl} = $new_tbl;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_alter_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  return;
}
sub alter_table_with_environment_context{
  my $self = shift;
  my $dbname = shift;
  my $tbl_name = shift;
  my $new_tbl = shift;
  my $environment_context = shift;

    $self->send_alter_table_with_environment_context($dbname, $tbl_name, $new_tbl, $environment_context);
  $self->recv_alter_table_with_environment_context();
}

sub send_alter_table_with_environment_context{
  my $self = shift;
  my $dbname = shift;
  my $tbl_name = shift;
  my $new_tbl = shift;
  my $environment_context = shift;

  $self->{output}->writeMessageBegin('alter_table_with_environment_context', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_table_with_environment_context_args();
  $args->{dbname} = $dbname;
  $args->{tbl_name} = $tbl_name;
  $args->{new_tbl} = $new_tbl;
  $args->{environment_context} = $environment_context;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_alter_table_with_environment_context{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_table_with_environment_context_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  return;
}
sub add_partition{
  my $self = shift;
  my $new_part = shift;

    $self->send_add_partition($new_part);
  return $self->recv_add_partition();
}

sub send_add_partition{
  my $self = shift;
  my $new_part = shift;

  $self->{output}->writeMessageBegin('add_partition', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_partition_args();
  $args->{new_part} = $new_part;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_add_partition{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_partition_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  die "add_partition failed: unknown result";
}
sub add_partition_with_environment_context{
  my $self = shift;
  my $new_part = shift;
  my $environment_context = shift;

    $self->send_add_partition_with_environment_context($new_part, $environment_context);
  return $self->recv_add_partition_with_environment_context();
}

sub send_add_partition_with_environment_context{
  my $self = shift;
  my $new_part = shift;
  my $environment_context = shift;

  $self->{output}->writeMessageBegin('add_partition_with_environment_context', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_partition_with_environment_context_args();
  $args->{new_part} = $new_part;
  $args->{environment_context} = $environment_context;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_add_partition_with_environment_context{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_partition_with_environment_context_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  die "add_partition_with_environment_context failed: unknown result";
}
sub add_partitions{
  my $self = shift;
  my $new_parts = shift;

    $self->send_add_partitions($new_parts);
  return $self->recv_add_partitions();
}

sub send_add_partitions{
  my $self = shift;
  my $new_parts = shift;

  $self->{output}->writeMessageBegin('add_partitions', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_partitions_args();
  $args->{new_parts} = $new_parts;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_add_partitions{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_partitions_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  die "add_partitions failed: unknown result";
}
sub append_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;

    $self->send_append_partition($db_name, $tbl_name, $part_vals);
  return $self->recv_append_partition();
}

sub send_append_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;

  $self->{output}->writeMessageBegin('append_partition', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_append_partition_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_vals} = $part_vals;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_append_partition{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_append_partition_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  die "append_partition failed: unknown result";
}
sub append_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;

    $self->send_append_partition_by_name($db_name, $tbl_name, $part_name);
  return $self->recv_append_partition_by_name();
}

sub send_append_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;

  $self->{output}->writeMessageBegin('append_partition_by_name', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_append_partition_by_name_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_name} = $part_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_append_partition_by_name{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_append_partition_by_name_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  die "append_partition_by_name failed: unknown result";
}
sub drop_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $deleteData = shift;

    $self->send_drop_partition($db_name, $tbl_name, $part_vals, $deleteData);
  return $self->recv_drop_partition();
}

sub send_drop_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $deleteData = shift;

  $self->{output}->writeMessageBegin('drop_partition', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_partition_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_vals} = $part_vals;
  $args->{deleteData} = $deleteData;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_partition{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_partition_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "drop_partition failed: unknown result";
}
sub drop_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;
  my $deleteData = shift;

    $self->send_drop_partition_by_name($db_name, $tbl_name, $part_name, $deleteData);
  return $self->recv_drop_partition_by_name();
}

sub send_drop_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;
  my $deleteData = shift;

  $self->{output}->writeMessageBegin('drop_partition_by_name', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_partition_by_name_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_name} = $part_name;
  $args->{deleteData} = $deleteData;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_partition_by_name{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_partition_by_name_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "drop_partition_by_name failed: unknown result";
}
sub get_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;

    $self->send_get_partition($db_name, $tbl_name, $part_vals);
  return $self->recv_get_partition();
}

sub send_get_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;

  $self->{output}->writeMessageBegin('get_partition', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_vals} = $part_vals;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partition{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_partition failed: unknown result";
}
sub get_partition_with_auth{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $user_name = shift;
  my $group_names = shift;

    $self->send_get_partition_with_auth($db_name, $tbl_name, $part_vals, $user_name, $group_names);
  return $self->recv_get_partition_with_auth();
}

sub send_get_partition_with_auth{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $user_name = shift;
  my $group_names = shift;

  $self->{output}->writeMessageBegin('get_partition_with_auth', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_with_auth_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_vals} = $part_vals;
  $args->{user_name} = $user_name;
  $args->{group_names} = $group_names;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partition_with_auth{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_with_auth_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_partition_with_auth failed: unknown result";
}
sub get_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;

    $self->send_get_partition_by_name($db_name, $tbl_name, $part_name);
  return $self->recv_get_partition_by_name();
}

sub send_get_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;

  $self->{output}->writeMessageBegin('get_partition_by_name', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_by_name_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_name} = $part_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partition_by_name{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_by_name_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_partition_by_name failed: unknown result";
}
sub get_partitions{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_parts = shift;

    $self->send_get_partitions($db_name, $tbl_name, $max_parts);
  return $self->recv_get_partitions();
}

sub send_get_partitions{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_parts = shift;

  $self->{output}->writeMessageBegin('get_partitions', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{max_parts} = $max_parts;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partitions{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_partitions failed: unknown result";
}
sub get_partitions_with_auth{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_parts = shift;
  my $user_name = shift;
  my $group_names = shift;

    $self->send_get_partitions_with_auth($db_name, $tbl_name, $max_parts, $user_name, $group_names);
  return $self->recv_get_partitions_with_auth();
}

sub send_get_partitions_with_auth{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_parts = shift;
  my $user_name = shift;
  my $group_names = shift;

  $self->{output}->writeMessageBegin('get_partitions_with_auth', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_with_auth_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{max_parts} = $max_parts;
  $args->{user_name} = $user_name;
  $args->{group_names} = $group_names;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partitions_with_auth{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_with_auth_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_partitions_with_auth failed: unknown result";
}
sub get_partition_names{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_parts = shift;

    $self->send_get_partition_names($db_name, $tbl_name, $max_parts);
  return $self->recv_get_partition_names();
}

sub send_get_partition_names{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_parts = shift;

  $self->{output}->writeMessageBegin('get_partition_names', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_names_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{max_parts} = $max_parts;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partition_names{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_names_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_partition_names failed: unknown result";
}
sub get_partitions_ps{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $max_parts = shift;

    $self->send_get_partitions_ps($db_name, $tbl_name, $part_vals, $max_parts);
  return $self->recv_get_partitions_ps();
}

sub send_get_partitions_ps{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $max_parts = shift;

  $self->{output}->writeMessageBegin('get_partitions_ps', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_ps_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_vals} = $part_vals;
  $args->{max_parts} = $max_parts;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partitions_ps{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_ps_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_partitions_ps failed: unknown result";
}
sub get_partitions_ps_with_auth{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $max_parts = shift;
  my $user_name = shift;
  my $group_names = shift;

    $self->send_get_partitions_ps_with_auth($db_name, $tbl_name, $part_vals, $max_parts, $user_name, $group_names);
  return $self->recv_get_partitions_ps_with_auth();
}

sub send_get_partitions_ps_with_auth{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $max_parts = shift;
  my $user_name = shift;
  my $group_names = shift;

  $self->{output}->writeMessageBegin('get_partitions_ps_with_auth', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_ps_with_auth_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_vals} = $part_vals;
  $args->{max_parts} = $max_parts;
  $args->{user_name} = $user_name;
  $args->{group_names} = $group_names;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partitions_ps_with_auth{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_ps_with_auth_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_partitions_ps_with_auth failed: unknown result";
}
sub get_partition_names_ps{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $max_parts = shift;

    $self->send_get_partition_names_ps($db_name, $tbl_name, $part_vals, $max_parts);
  return $self->recv_get_partition_names_ps();
}

sub send_get_partition_names_ps{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $max_parts = shift;

  $self->{output}->writeMessageBegin('get_partition_names_ps', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_names_ps_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_vals} = $part_vals;
  $args->{max_parts} = $max_parts;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partition_names_ps{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_names_ps_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_partition_names_ps failed: unknown result";
}
sub get_partitions_by_filter{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $filter = shift;
  my $max_parts = shift;

    $self->send_get_partitions_by_filter($db_name, $tbl_name, $filter, $max_parts);
  return $self->recv_get_partitions_by_filter();
}

sub send_get_partitions_by_filter{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $filter = shift;
  my $max_parts = shift;

  $self->{output}->writeMessageBegin('get_partitions_by_filter', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_by_filter_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{filter} = $filter;
  $args->{max_parts} = $max_parts;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partitions_by_filter{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_by_filter_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_partitions_by_filter failed: unknown result";
}
sub get_partitions_by_names{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $names = shift;

    $self->send_get_partitions_by_names($db_name, $tbl_name, $names);
  return $self->recv_get_partitions_by_names();
}

sub send_get_partitions_by_names{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $names = shift;

  $self->{output}->writeMessageBegin('get_partitions_by_names', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_by_names_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{names} = $names;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partitions_by_names{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_by_names_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_partitions_by_names failed: unknown result";
}
sub alter_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $new_part = shift;

    $self->send_alter_partition($db_name, $tbl_name, $new_part);
  $self->recv_alter_partition();
}

sub send_alter_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $new_part = shift;

  $self->{output}->writeMessageBegin('alter_partition', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_partition_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{new_part} = $new_part;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_alter_partition{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_partition_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  return;
}
sub alter_partition_with_environment_context{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $new_part = shift;
  my $environment_context = shift;

    $self->send_alter_partition_with_environment_context($db_name, $tbl_name, $new_part, $environment_context);
  $self->recv_alter_partition_with_environment_context();
}

sub send_alter_partition_with_environment_context{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $new_part = shift;
  my $environment_context = shift;

  $self->{output}->writeMessageBegin('alter_partition_with_environment_context', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_partition_with_environment_context_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{new_part} = $new_part;
  $args->{environment_context} = $environment_context;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_alter_partition_with_environment_context{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_partition_with_environment_context_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  return;
}
sub rename_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $new_part = shift;

    $self->send_rename_partition($db_name, $tbl_name, $part_vals, $new_part);
  $self->recv_rename_partition();
}

sub send_rename_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $new_part = shift;

  $self->{output}->writeMessageBegin('rename_partition', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_rename_partition_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_vals} = $part_vals;
  $args->{new_part} = $new_part;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_rename_partition{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_rename_partition_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  return;
}
sub get_config_value{
  my $self = shift;
  my $name = shift;
  my $defaultValue = shift;

    $self->send_get_config_value($name, $defaultValue);
  return $self->recv_get_config_value();
}

sub send_get_config_value{
  my $self = shift;
  my $name = shift;
  my $defaultValue = shift;

  $self->{output}->writeMessageBegin('get_config_value', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_config_value_args();
  $args->{name} = $name;
  $args->{defaultValue} = $defaultValue;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_config_value{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_config_value_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_config_value failed: unknown result";
}
sub partition_name_to_vals{
  my $self = shift;
  my $part_name = shift;

    $self->send_partition_name_to_vals($part_name);
  return $self->recv_partition_name_to_vals();
}

sub send_partition_name_to_vals{
  my $self = shift;
  my $part_name = shift;

  $self->{output}->writeMessageBegin('partition_name_to_vals', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_partition_name_to_vals_args();
  $args->{part_name} = $part_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_partition_name_to_vals{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_partition_name_to_vals_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "partition_name_to_vals failed: unknown result";
}
sub partition_name_to_spec{
  my $self = shift;
  my $part_name = shift;

    $self->send_partition_name_to_spec($part_name);
  return $self->recv_partition_name_to_spec();
}

sub send_partition_name_to_spec{
  my $self = shift;
  my $part_name = shift;

  $self->{output}->writeMessageBegin('partition_name_to_spec', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_partition_name_to_spec_args();
  $args->{part_name} = $part_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_partition_name_to_spec{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_partition_name_to_spec_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "partition_name_to_spec failed: unknown result";
}
sub markPartitionForEvent{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $eventType = shift;

    $self->send_markPartitionForEvent($db_name, $tbl_name, $part_vals, $eventType);
  $self->recv_markPartitionForEvent();
}

sub send_markPartitionForEvent{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $eventType = shift;

  $self->{output}->writeMessageBegin('markPartitionForEvent', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_markPartitionForEvent_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_vals} = $part_vals;
  $args->{eventType} = $eventType;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_markPartitionForEvent{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_markPartitionForEvent_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  if (defined $result->{o4}) {
    die $result->{o4};
  }
  if (defined $result->{o5}) {
    die $result->{o5};
  }
  if (defined $result->{o6}) {
    die $result->{o6};
  }
  return;
}
sub isPartitionMarkedForEvent{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $eventType = shift;

    $self->send_isPartitionMarkedForEvent($db_name, $tbl_name, $part_vals, $eventType);
  return $self->recv_isPartitionMarkedForEvent();
}

sub send_isPartitionMarkedForEvent{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $eventType = shift;

  $self->{output}->writeMessageBegin('isPartitionMarkedForEvent', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_isPartitionMarkedForEvent_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_vals} = $part_vals;
  $args->{eventType} = $eventType;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_isPartitionMarkedForEvent{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_isPartitionMarkedForEvent_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  if (defined $result->{o4}) {
    die $result->{o4};
  }
  if (defined $result->{o5}) {
    die $result->{o5};
  }
  if (defined $result->{o6}) {
    die $result->{o6};
  }
  die "isPartitionMarkedForEvent failed: unknown result";
}
sub add_index{
  my $self = shift;
  my $new_index = shift;
  my $index_table = shift;

    $self->send_add_index($new_index, $index_table);
  return $self->recv_add_index();
}

sub send_add_index{
  my $self = shift;
  my $new_index = shift;
  my $index_table = shift;

  $self->{output}->writeMessageBegin('add_index', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_index_args();
  $args->{new_index} = $new_index;
  $args->{index_table} = $index_table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_add_index{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_index_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  die "add_index failed: unknown result";
}
sub alter_index{
  my $self = shift;
  my $dbname = shift;
  my $base_tbl_name = shift;
  my $idx_name = shift;
  my $new_idx = shift;

    $self->send_alter_index($dbname, $base_tbl_name, $idx_name, $new_idx);
  $self->recv_alter_index();
}

sub send_alter_index{
  my $self = shift;
  my $dbname = shift;
  my $base_tbl_name = shift;
  my $idx_name = shift;
  my $new_idx = shift;

  $self->{output}->writeMessageBegin('alter_index', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_index_args();
  $args->{dbname} = $dbname;
  $args->{base_tbl_name} = $base_tbl_name;
  $args->{idx_name} = $idx_name;
  $args->{new_idx} = $new_idx;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_alter_index{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_index_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  return;
}
sub drop_index_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $index_name = shift;
  my $deleteData = shift;

    $self->send_drop_index_by_name($db_name, $tbl_name, $index_name, $deleteData);
  return $self->recv_drop_index_by_name();
}

sub send_drop_index_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $index_name = shift;
  my $deleteData = shift;

  $self->{output}->writeMessageBegin('drop_index_by_name', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_index_by_name_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{index_name} = $index_name;
  $args->{deleteData} = $deleteData;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_index_by_name{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_index_by_name_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "drop_index_by_name failed: unknown result";
}
sub get_index_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $index_name = shift;

    $self->send_get_index_by_name($db_name, $tbl_name, $index_name);
  return $self->recv_get_index_by_name();
}

sub send_get_index_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $index_name = shift;

  $self->{output}->writeMessageBegin('get_index_by_name', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_index_by_name_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{index_name} = $index_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_index_by_name{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_index_by_name_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_index_by_name failed: unknown result";
}
sub get_indexes{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_indexes = shift;

    $self->send_get_indexes($db_name, $tbl_name, $max_indexes);
  return $self->recv_get_indexes();
}

sub send_get_indexes{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_indexes = shift;

  $self->{output}->writeMessageBegin('get_indexes', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_indexes_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{max_indexes} = $max_indexes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_indexes{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_indexes_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_indexes failed: unknown result";
}
sub get_index_names{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_indexes = shift;

    $self->send_get_index_names($db_name, $tbl_name, $max_indexes);
  return $self->recv_get_index_names();
}

sub send_get_index_names{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_indexes = shift;

  $self->{output}->writeMessageBegin('get_index_names', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_index_names_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{max_indexes} = $max_indexes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_index_names{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_index_names_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_index_names failed: unknown result";
}
sub create_role{
  my $self = shift;
  my $role = shift;

    $self->send_create_role($role);
  return $self->recv_create_role();
}

sub send_create_role{
  my $self = shift;
  my $role = shift;

  $self->{output}->writeMessageBegin('create_role', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_role_args();
  $args->{role} = $role;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_create_role{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_role_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "create_role failed: unknown result";
}
sub drop_role{
  my $self = shift;
  my $role_name = shift;

    $self->send_drop_role($role_name);
  return $self->recv_drop_role();
}

sub send_drop_role{
  my $self = shift;
  my $role_name = shift;

  $self->{output}->writeMessageBegin('drop_role', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_role_args();
  $args->{role_name} = $role_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_role{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_role_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "drop_role failed: unknown result";
}
sub get_role_names{
  my $self = shift;

    $self->send_get_role_names();
  return $self->recv_get_role_names();
}

sub send_get_role_names{
  my $self = shift;

  $self->{output}->writeMessageBegin('get_role_names', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_role_names_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_role_names{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_role_names_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_role_names failed: unknown result";
}
sub grant_role{
  my $self = shift;
  my $role_name = shift;
  my $principal_name = shift;
  my $principal_type = shift;
  my $grantor = shift;
  my $grantorType = shift;
  my $grant_option = shift;

    $self->send_grant_role($role_name, $principal_name, $principal_type, $grantor, $grantorType, $grant_option);
  return $self->recv_grant_role();
}

sub send_grant_role{
  my $self = shift;
  my $role_name = shift;
  my $principal_name = shift;
  my $principal_type = shift;
  my $grantor = shift;
  my $grantorType = shift;
  my $grant_option = shift;

  $self->{output}->writeMessageBegin('grant_role', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_grant_role_args();
  $args->{role_name} = $role_name;
  $args->{principal_name} = $principal_name;
  $args->{principal_type} = $principal_type;
  $args->{grantor} = $grantor;
  $args->{grantorType} = $grantorType;
  $args->{grant_option} = $grant_option;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_grant_role{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_grant_role_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "grant_role failed: unknown result";
}
sub revoke_role{
  my $self = shift;
  my $role_name = shift;
  my $principal_name = shift;
  my $principal_type = shift;

    $self->send_revoke_role($role_name, $principal_name, $principal_type);
  return $self->recv_revoke_role();
}

sub send_revoke_role{
  my $self = shift;
  my $role_name = shift;
  my $principal_name = shift;
  my $principal_type = shift;

  $self->{output}->writeMessageBegin('revoke_role', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_revoke_role_args();
  $args->{role_name} = $role_name;
  $args->{principal_name} = $principal_name;
  $args->{principal_type} = $principal_type;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_revoke_role{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_revoke_role_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "revoke_role failed: unknown result";
}
sub list_roles{
  my $self = shift;
  my $principal_name = shift;
  my $principal_type = shift;

    $self->send_list_roles($principal_name, $principal_type);
  return $self->recv_list_roles();
}

sub send_list_roles{
  my $self = shift;
  my $principal_name = shift;
  my $principal_type = shift;

  $self->{output}->writeMessageBegin('list_roles', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_list_roles_args();
  $args->{principal_name} = $principal_name;
  $args->{principal_type} = $principal_type;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_list_roles{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_list_roles_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "list_roles failed: unknown result";
}
sub get_privilege_set{
  my $self = shift;
  my $hiveObject = shift;
  my $user_name = shift;
  my $group_names = shift;

    $self->send_get_privilege_set($hiveObject, $user_name, $group_names);
  return $self->recv_get_privilege_set();
}

sub send_get_privilege_set{
  my $self = shift;
  my $hiveObject = shift;
  my $user_name = shift;
  my $group_names = shift;

  $self->{output}->writeMessageBegin('get_privilege_set', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_privilege_set_args();
  $args->{hiveObject} = $hiveObject;
  $args->{user_name} = $user_name;
  $args->{group_names} = $group_names;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_privilege_set{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_privilege_set_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_privilege_set failed: unknown result";
}
sub list_privileges{
  my $self = shift;
  my $principal_name = shift;
  my $principal_type = shift;
  my $hiveObject = shift;

    $self->send_list_privileges($principal_name, $principal_type, $hiveObject);
  return $self->recv_list_privileges();
}

sub send_list_privileges{
  my $self = shift;
  my $principal_name = shift;
  my $principal_type = shift;
  my $hiveObject = shift;

  $self->{output}->writeMessageBegin('list_privileges', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_list_privileges_args();
  $args->{principal_name} = $principal_name;
  $args->{principal_type} = $principal_type;
  $args->{hiveObject} = $hiveObject;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_list_privileges{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_list_privileges_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "list_privileges failed: unknown result";
}
sub grant_privileges{
  my $self = shift;
  my $privileges = shift;

    $self->send_grant_privileges($privileges);
  return $self->recv_grant_privileges();
}

sub send_grant_privileges{
  my $self = shift;
  my $privileges = shift;

  $self->{output}->writeMessageBegin('grant_privileges', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_grant_privileges_args();
  $args->{privileges} = $privileges;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_grant_privileges{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_grant_privileges_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "grant_privileges failed: unknown result";
}
sub revoke_privileges{
  my $self = shift;
  my $privileges = shift;

    $self->send_revoke_privileges($privileges);
  return $self->recv_revoke_privileges();
}

sub send_revoke_privileges{
  my $self = shift;
  my $privileges = shift;

  $self->{output}->writeMessageBegin('revoke_privileges', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_revoke_privileges_args();
  $args->{privileges} = $privileges;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_revoke_privileges{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_revoke_privileges_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "revoke_privileges failed: unknown result";
}
sub set_ugi{
  my $self = shift;
  my $user_name = shift;
  my $group_names = shift;

    $self->send_set_ugi($user_name, $group_names);
  return $self->recv_set_ugi();
}

sub send_set_ugi{
  my $self = shift;
  my $user_name = shift;
  my $group_names = shift;

  $self->{output}->writeMessageBegin('set_ugi', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_set_ugi_args();
  $args->{user_name} = $user_name;
  $args->{group_names} = $group_names;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_ugi{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_set_ugi_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "set_ugi failed: unknown result";
}
sub get_delegation_token{
  my $self = shift;
  my $token_owner = shift;
  my $renewer_kerberos_principal_name = shift;

    $self->send_get_delegation_token($token_owner, $renewer_kerberos_principal_name);
  return $self->recv_get_delegation_token();
}

sub send_get_delegation_token{
  my $self = shift;
  my $token_owner = shift;
  my $renewer_kerberos_principal_name = shift;

  $self->{output}->writeMessageBegin('get_delegation_token', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_delegation_token_args();
  $args->{token_owner} = $token_owner;
  $args->{renewer_kerberos_principal_name} = $renewer_kerberos_principal_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_delegation_token{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_delegation_token_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_delegation_token failed: unknown result";
}
sub renew_delegation_token{
  my $self = shift;
  my $token_str_form = shift;

    $self->send_renew_delegation_token($token_str_form);
  return $self->recv_renew_delegation_token();
}

sub send_renew_delegation_token{
  my $self = shift;
  my $token_str_form = shift;

  $self->{output}->writeMessageBegin('renew_delegation_token', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_renew_delegation_token_args();
  $args->{token_str_form} = $token_str_form;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_renew_delegation_token{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_renew_delegation_token_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "renew_delegation_token failed: unknown result";
}
sub cancel_delegation_token{
  my $self = shift;
  my $token_str_form = shift;

    $self->send_cancel_delegation_token($token_str_form);
  $self->recv_cancel_delegation_token();
}

sub send_cancel_delegation_token{
  my $self = shift;
  my $token_str_form = shift;

  $self->{output}->writeMessageBegin('cancel_delegation_token', TMessageType::CALL, $self->{seqid});
  my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_cancel_delegation_token_args();
  $args->{token_str_form} = $token_str_form;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_cancel_delegation_token{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_cancel_delegation_token_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  return;
}
package
	Impala::Protocol::HiveMetastore::ThriftHiveMetastoreProcessor;

use strict;
use base qw(Impala::Protocol::fb303::FacebookServiceProcessor);

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_create_database {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_database_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_database_result();
    eval {
      $self->{handler}->create_database($args->database);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::AlreadyExistsException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::InvalidObjectException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('create_database', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_database {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_database_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_database_result();
    eval {
      $result->{success} = $self->{handler}->get_database($args->name);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_database', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_database {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_database_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_database_result();
    eval {
      $self->{handler}->drop_database($args->name, $args->deleteData, $args->cascade);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::InvalidOperationException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('drop_database', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_databases {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_databases_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_databases_result();
    eval {
      $result->{success} = $self->{handler}->get_databases($args->pattern);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_databases', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_all_databases {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_all_databases_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_all_databases_result();
    eval {
      $result->{success} = $self->{handler}->get_all_databases();
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_all_databases', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_alter_database {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_database_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_database_result();
    eval {
      $self->{handler}->alter_database($args->dbname, $args->db);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('alter_database', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_type {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_type_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_type_result();
    eval {
      $result->{success} = $self->{handler}->get_type($args->name);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_type', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_create_type {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_type_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_type_result();
    eval {
      $result->{success} = $self->{handler}->create_type($args->type);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::AlreadyExistsException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::InvalidObjectException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('create_type', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_type {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_type_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_type_result();
    eval {
      $result->{success} = $self->{handler}->drop_type($args->type);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('drop_type', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_type_all {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_type_all_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_type_all_result();
    eval {
      $result->{success} = $self->{handler}->get_type_all($args->name);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_type_all', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_fields {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_fields_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_fields_result();
    eval {
      $result->{success} = $self->{handler}->get_fields($args->db_name, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::UnknownTableException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::UnknownDBException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('get_fields', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_schema {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_schema_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_schema_result();
    eval {
      $result->{success} = $self->{handler}->get_schema($args->db_name, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::UnknownTableException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::UnknownDBException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('get_schema', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_create_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_table_result();
    eval {
      $self->{handler}->create_table($args->tbl);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::AlreadyExistsException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::InvalidObjectException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o3} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o4} = $@;
    }
    $output->writeMessageBegin('create_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_create_table_with_environment_context {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_table_with_environment_context_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_table_with_environment_context_result();
    eval {
      $self->{handler}->create_table_with_environment_context($args->tbl, $args->environment_context);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::AlreadyExistsException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::InvalidObjectException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o3} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o4} = $@;
    }
    $output->writeMessageBegin('create_table_with_environment_context', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_table_result();
    eval {
      $self->{handler}->drop_table($args->dbname, $args->name, $args->deleteData);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('drop_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_tables {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_tables_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_tables_result();
    eval {
      $result->{success} = $self->{handler}->get_tables($args->db_name, $args->pattern);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_tables', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_all_tables {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_all_tables_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_all_tables_result();
    eval {
      $result->{success} = $self->{handler}->get_all_tables($args->db_name);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_all_tables', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_table_result();
    eval {
      $result->{success} = $self->{handler}->get_table($args->dbname, $args->tbl_name);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_table_objects_by_name {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_table_objects_by_name_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_table_objects_by_name_result();
    eval {
      $result->{success} = $self->{handler}->get_table_objects_by_name($args->dbname, $args->tbl_names);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::InvalidOperationException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::UnknownDBException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('get_table_objects_by_name', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_table_names_by_filter {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_table_names_by_filter_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_table_names_by_filter_result();
    eval {
      $result->{success} = $self->{handler}->get_table_names_by_filter($args->dbname, $args->filter, $args->max_tables);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::InvalidOperationException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::UnknownDBException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('get_table_names_by_filter', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_alter_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_table_result();
    eval {
      $self->{handler}->alter_table($args->dbname, $args->tbl_name, $args->new_tbl);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::InvalidOperationException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('alter_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_alter_table_with_environment_context {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_table_with_environment_context_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_table_with_environment_context_result();
    eval {
      $self->{handler}->alter_table_with_environment_context($args->dbname, $args->tbl_name, $args->new_tbl, $args->environment_context);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::InvalidOperationException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('alter_table_with_environment_context', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_add_partition {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_partition_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_partition_result();
    eval {
      $result->{success} = $self->{handler}->add_partition($args->new_part);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::InvalidObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::AlreadyExistsException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('add_partition', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_add_partition_with_environment_context {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_partition_with_environment_context_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_partition_with_environment_context_result();
    eval {
      $result->{success} = $self->{handler}->add_partition_with_environment_context($args->new_part, $args->environment_context);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::InvalidObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::AlreadyExistsException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('add_partition_with_environment_context', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_add_partitions {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_partitions_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_partitions_result();
    eval {
      $result->{success} = $self->{handler}->add_partitions($args->new_parts);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::InvalidObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::AlreadyExistsException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('add_partitions', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_append_partition {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_append_partition_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_append_partition_result();
    eval {
      $result->{success} = $self->{handler}->append_partition($args->db_name, $args->tbl_name, $args->part_vals);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::InvalidObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::AlreadyExistsException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('append_partition', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_append_partition_by_name {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_append_partition_by_name_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_append_partition_by_name_result();
    eval {
      $result->{success} = $self->{handler}->append_partition_by_name($args->db_name, $args->tbl_name, $args->part_name);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::InvalidObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::AlreadyExistsException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('append_partition_by_name', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_partition {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_partition_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_partition_result();
    eval {
      $result->{success} = $self->{handler}->drop_partition($args->db_name, $args->tbl_name, $args->part_vals, $args->deleteData);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('drop_partition', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_partition_by_name {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_partition_by_name_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_partition_by_name_result();
    eval {
      $result->{success} = $self->{handler}->drop_partition_by_name($args->db_name, $args->tbl_name, $args->part_name, $args->deleteData);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('drop_partition_by_name', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partition {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_result();
    eval {
      $result->{success} = $self->{handler}->get_partition($args->db_name, $args->tbl_name, $args->part_vals);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_partition', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partition_with_auth {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_with_auth_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_with_auth_result();
    eval {
      $result->{success} = $self->{handler}->get_partition_with_auth($args->db_name, $args->tbl_name, $args->part_vals, $args->user_name, $args->group_names);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_partition_with_auth', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partition_by_name {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_by_name_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_by_name_result();
    eval {
      $result->{success} = $self->{handler}->get_partition_by_name($args->db_name, $args->tbl_name, $args->part_name);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_partition_by_name', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partitions {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_result();
    eval {
      $result->{success} = $self->{handler}->get_partitions($args->db_name, $args->tbl_name, $args->max_parts);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_partitions', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partitions_with_auth {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_with_auth_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_with_auth_result();
    eval {
      $result->{success} = $self->{handler}->get_partitions_with_auth($args->db_name, $args->tbl_name, $args->max_parts, $args->user_name, $args->group_names);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_partitions_with_auth', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partition_names {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_names_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_names_result();
    eval {
      $result->{success} = $self->{handler}->get_partition_names($args->db_name, $args->tbl_name, $args->max_parts);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_partition_names', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partitions_ps {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_ps_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_ps_result();
    eval {
      $result->{success} = $self->{handler}->get_partitions_ps($args->db_name, $args->tbl_name, $args->part_vals, $args->max_parts);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_partitions_ps', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partitions_ps_with_auth {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_ps_with_auth_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_ps_with_auth_result();
    eval {
      $result->{success} = $self->{handler}->get_partitions_ps_with_auth($args->db_name, $args->tbl_name, $args->part_vals, $args->max_parts, $args->user_name, $args->group_names);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_partitions_ps_with_auth', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partition_names_ps {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_names_ps_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partition_names_ps_result();
    eval {
      $result->{success} = $self->{handler}->get_partition_names_ps($args->db_name, $args->tbl_name, $args->part_vals, $args->max_parts);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_partition_names_ps', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partitions_by_filter {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_by_filter_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_by_filter_result();
    eval {
      $result->{success} = $self->{handler}->get_partitions_by_filter($args->db_name, $args->tbl_name, $args->filter, $args->max_parts);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_partitions_by_filter', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partitions_by_names {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_by_names_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_partitions_by_names_result();
    eval {
      $result->{success} = $self->{handler}->get_partitions_by_names($args->db_name, $args->tbl_name, $args->names);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_partitions_by_names', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_alter_partition {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_partition_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_partition_result();
    eval {
      $self->{handler}->alter_partition($args->db_name, $args->tbl_name, $args->new_part);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::InvalidOperationException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('alter_partition', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_alter_partition_with_environment_context {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_partition_with_environment_context_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_partition_with_environment_context_result();
    eval {
      $self->{handler}->alter_partition_with_environment_context($args->db_name, $args->tbl_name, $args->new_part, $args->environment_context);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::InvalidOperationException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('alter_partition_with_environment_context', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_rename_partition {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_rename_partition_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_rename_partition_result();
    eval {
      $self->{handler}->rename_partition($args->db_name, $args->tbl_name, $args->part_vals, $args->new_part);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::InvalidOperationException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('rename_partition', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_config_value {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_config_value_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_config_value_result();
    eval {
      $result->{success} = $self->{handler}->get_config_value($args->name, $args->defaultValue);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::ConfigValSecurityException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_config_value', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_partition_name_to_vals {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_partition_name_to_vals_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_partition_name_to_vals_result();
    eval {
      $result->{success} = $self->{handler}->partition_name_to_vals($args->part_name);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('partition_name_to_vals', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_partition_name_to_spec {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_partition_name_to_spec_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_partition_name_to_spec_result();
    eval {
      $result->{success} = $self->{handler}->partition_name_to_spec($args->part_name);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('partition_name_to_spec', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_markPartitionForEvent {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_markPartitionForEvent_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_markPartitionForEvent_result();
    eval {
      $self->{handler}->markPartitionForEvent($args->db_name, $args->tbl_name, $args->part_vals, $args->eventType);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::UnknownDBException') ){ 
      $result->{o3} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::UnknownTableException') ){ 
      $result->{o4} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::UnknownPartitionException') ){ 
      $result->{o5} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::InvalidPartitionException') ){ 
      $result->{o6} = $@;
    }
    $output->writeMessageBegin('markPartitionForEvent', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_isPartitionMarkedForEvent {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_isPartitionMarkedForEvent_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_isPartitionMarkedForEvent_result();
    eval {
      $result->{success} = $self->{handler}->isPartitionMarkedForEvent($args->db_name, $args->tbl_name, $args->part_vals, $args->eventType);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::UnknownDBException') ){ 
      $result->{o3} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::UnknownTableException') ){ 
      $result->{o4} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::UnknownPartitionException') ){ 
      $result->{o5} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::InvalidPartitionException') ){ 
      $result->{o6} = $@;
    }
    $output->writeMessageBegin('isPartitionMarkedForEvent', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_add_index {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_index_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_add_index_result();
    eval {
      $result->{success} = $self->{handler}->add_index($args->new_index, $args->index_table);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::InvalidObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::AlreadyExistsException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('add_index', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_alter_index {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_index_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_alter_index_result();
    eval {
      $self->{handler}->alter_index($args->dbname, $args->base_tbl_name, $args->idx_name, $args->new_idx);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::InvalidOperationException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('alter_index', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_index_by_name {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_index_by_name_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_index_by_name_result();
    eval {
      $result->{success} = $self->{handler}->drop_index_by_name($args->db_name, $args->tbl_name, $args->index_name, $args->deleteData);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('drop_index_by_name', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_index_by_name {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_index_by_name_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_index_by_name_result();
    eval {
      $result->{success} = $self->{handler}->get_index_by_name($args->db_name, $args->tbl_name, $args->index_name);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_index_by_name', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_indexes {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_indexes_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_indexes_result();
    eval {
      $result->{success} = $self->{handler}->get_indexes($args->db_name, $args->tbl_name, $args->max_indexes);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_indexes', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_index_names {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_index_names_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_index_names_result();
    eval {
      $result->{success} = $self->{handler}->get_index_names($args->db_name, $args->tbl_name, $args->max_indexes);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_index_names', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_create_role {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_role_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_create_role_result();
    eval {
      $result->{success} = $self->{handler}->create_role($args->role);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('create_role', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_role {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_role_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_drop_role_result();
    eval {
      $result->{success} = $self->{handler}->drop_role($args->role_name);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('drop_role', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_role_names {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_role_names_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_role_names_result();
    eval {
      $result->{success} = $self->{handler}->get_role_names();
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_role_names', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_grant_role {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_grant_role_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_grant_role_result();
    eval {
      $result->{success} = $self->{handler}->grant_role($args->role_name, $args->principal_name, $args->principal_type, $args->grantor, $args->grantorType, $args->grant_option);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('grant_role', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_revoke_role {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_revoke_role_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_revoke_role_result();
    eval {
      $result->{success} = $self->{handler}->revoke_role($args->role_name, $args->principal_name, $args->principal_type);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('revoke_role', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_list_roles {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_list_roles_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_list_roles_result();
    eval {
      $result->{success} = $self->{handler}->list_roles($args->principal_name, $args->principal_type);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('list_roles', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_privilege_set {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_privilege_set_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_privilege_set_result();
    eval {
      $result->{success} = $self->{handler}->get_privilege_set($args->hiveObject, $args->user_name, $args->group_names);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_privilege_set', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_list_privileges {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_list_privileges_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_list_privileges_result();
    eval {
      $result->{success} = $self->{handler}->list_privileges($args->principal_name, $args->principal_type, $args->hiveObject);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('list_privileges', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_grant_privileges {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_grant_privileges_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_grant_privileges_result();
    eval {
      $result->{success} = $self->{handler}->grant_privileges($args->privileges);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('grant_privileges', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_revoke_privileges {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_revoke_privileges_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_revoke_privileges_result();
    eval {
      $result->{success} = $self->{handler}->revoke_privileges($args->privileges);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('revoke_privileges', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_ugi {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_set_ugi_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_set_ugi_result();
    eval {
      $result->{success} = $self->{handler}->set_ugi($args->user_name, $args->group_names);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('set_ugi', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_delegation_token {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_delegation_token_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_get_delegation_token_result();
    eval {
      $result->{success} = $self->{handler}->get_delegation_token($args->token_owner, $args->renewer_kerberos_principal_name);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_delegation_token', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_renew_delegation_token {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_renew_delegation_token_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_renew_delegation_token_result();
    eval {
      $result->{success} = $self->{handler}->renew_delegation_token($args->token_str_form);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('renew_delegation_token', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_cancel_delegation_token {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_cancel_delegation_token_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Impala::Protocol::HiveMetastore::ThriftHiveMetastore_cancel_delegation_token_result();
    eval {
      $self->{handler}->cancel_delegation_token($args->token_str_form);
    }; if( UNIVERSAL::isa($@,'Impala::Protocol::HiveMetastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('cancel_delegation_token', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
