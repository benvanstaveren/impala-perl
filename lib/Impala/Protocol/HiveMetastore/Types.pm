#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

package
	Impala::Protocol::HiveMetastore::HiveObjectType;
use constant GLOBAL => 1;
use constant DATABASE => 2;
use constant TABLE => 3;
use constant PARTITION => 4;
use constant COLUMN => 5;
package
	Impala::Protocol::HiveMetastore::PrincipalType;
use constant USER => 1;
use constant ROLE => 2;
use constant GROUP => 3;
package
	Impala::Protocol::HiveMetastore::PartitionEventType;
use constant LOAD_DONE => 1;
package
	Impala::Protocol::HiveMetastore::Version;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::Version->mk_accessors( qw( version comments ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{version} = undef;
  $self->{comments} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{version}) {
      $self->{version} = $vals->{version};
    }
    if (defined $vals->{comments}) {
      $self->{comments} = $vals->{comments};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Version';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{version});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{comments});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Version');
  if (defined $self->{version}) {
    $xfer += $output->writeFieldBegin('version', TType::STRING, 1);
    $xfer += $output->writeString($self->{version});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{comments}) {
    $xfer += $output->writeFieldBegin('comments', TType::STRING, 2);
    $xfer += $output->writeString($self->{comments});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::FieldSchema;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::FieldSchema->mk_accessors( qw( name type comment ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{type} = undef;
  $self->{comment} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
    if (defined $vals->{comment}) {
      $self->{comment} = $vals->{comment};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'FieldSchema';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{comment});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('FieldSchema');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::STRING, 2);
    $xfer += $output->writeString($self->{type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{comment}) {
    $xfer += $output->writeFieldBegin('comment', TType::STRING, 3);
    $xfer += $output->writeString($self->{comment});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::Type;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::Type->mk_accessors( qw( name type1 type2 ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{type1} = undef;
  $self->{type2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{type1}) {
      $self->{type1} = $vals->{type1};
    }
    if (defined $vals->{type2}) {
      $self->{type2} = $vals->{type2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Type';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{type1});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{type2});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Type');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{type1}) {
    $xfer += $output->writeFieldBegin('type1', TType::STRING, 2);
    $xfer += $output->writeString($self->{type1});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{type2}) {
    $xfer += $output->writeFieldBegin('type2', TType::STRING, 3);
    $xfer += $output->writeString($self->{type2});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::HiveObjectRef;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::HiveObjectRef->mk_accessors( qw( objectType dbName objectName partValues columnName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{objectType} = undef;
  $self->{dbName} = undef;
  $self->{objectName} = undef;
  $self->{partValues} = undef;
  $self->{columnName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{objectType}) {
      $self->{objectType} = $vals->{objectType};
    }
    if (defined $vals->{dbName}) {
      $self->{dbName} = $vals->{dbName};
    }
    if (defined $vals->{objectName}) {
      $self->{objectName} = $vals->{objectName};
    }
    if (defined $vals->{partValues}) {
      $self->{partValues} = $vals->{partValues};
    }
    if (defined $vals->{columnName}) {
      $self->{columnName} = $vals->{columnName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'HiveObjectRef';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{objectType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dbName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{objectName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size0 = 0;
          $self->{partValues} = [];
          my $_etype3 = 0;
          $xfer += $input->readListBegin(\$_etype3, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $elem5 = undef;
            $xfer += $input->readString(\$elem5);
            push(@{$self->{partValues}},$elem5);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{columnName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('HiveObjectRef');
  if (defined $self->{objectType}) {
    $xfer += $output->writeFieldBegin('objectType', TType::I32, 1);
    $xfer += $output->writeI32($self->{objectType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{dbName}) {
    $xfer += $output->writeFieldBegin('dbName', TType::STRING, 2);
    $xfer += $output->writeString($self->{dbName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{objectName}) {
    $xfer += $output->writeFieldBegin('objectName', TType::STRING, 3);
    $xfer += $output->writeString($self->{objectName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{partValues}) {
    $xfer += $output->writeFieldBegin('partValues', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{partValues}}));
      {
        foreach my $iter6 (@{$self->{partValues}}) 
        {
          $xfer += $output->writeString($iter6);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnName}) {
    $xfer += $output->writeFieldBegin('columnName', TType::STRING, 5);
    $xfer += $output->writeString($self->{columnName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::PrivilegeGrantInfo;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::PrivilegeGrantInfo->mk_accessors( qw( privilege createTime grantor grantorType grantOption ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{privilege} = undef;
  $self->{createTime} = undef;
  $self->{grantor} = undef;
  $self->{grantorType} = undef;
  $self->{grantOption} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{privilege}) {
      $self->{privilege} = $vals->{privilege};
    }
    if (defined $vals->{createTime}) {
      $self->{createTime} = $vals->{createTime};
    }
    if (defined $vals->{grantor}) {
      $self->{grantor} = $vals->{grantor};
    }
    if (defined $vals->{grantorType}) {
      $self->{grantorType} = $vals->{grantorType};
    }
    if (defined $vals->{grantOption}) {
      $self->{grantOption} = $vals->{grantOption};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'PrivilegeGrantInfo';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{privilege});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{createTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{grantor});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{grantorType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{grantOption});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('PrivilegeGrantInfo');
  if (defined $self->{privilege}) {
    $xfer += $output->writeFieldBegin('privilege', TType::STRING, 1);
    $xfer += $output->writeString($self->{privilege});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{createTime}) {
    $xfer += $output->writeFieldBegin('createTime', TType::I32, 2);
    $xfer += $output->writeI32($self->{createTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{grantor}) {
    $xfer += $output->writeFieldBegin('grantor', TType::STRING, 3);
    $xfer += $output->writeString($self->{grantor});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{grantorType}) {
    $xfer += $output->writeFieldBegin('grantorType', TType::I32, 4);
    $xfer += $output->writeI32($self->{grantorType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{grantOption}) {
    $xfer += $output->writeFieldBegin('grantOption', TType::BOOL, 5);
    $xfer += $output->writeBool($self->{grantOption});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::HiveObjectPrivilege;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::HiveObjectPrivilege->mk_accessors( qw( hiveObject principalName principalType grantInfo ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{hiveObject} = undef;
  $self->{principalName} = undef;
  $self->{principalType} = undef;
  $self->{grantInfo} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{hiveObject}) {
      $self->{hiveObject} = $vals->{hiveObject};
    }
    if (defined $vals->{principalName}) {
      $self->{principalName} = $vals->{principalName};
    }
    if (defined $vals->{principalType}) {
      $self->{principalType} = $vals->{principalType};
    }
    if (defined $vals->{grantInfo}) {
      $self->{grantInfo} = $vals->{grantInfo};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'HiveObjectPrivilege';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{hiveObject} = new Impala::Protocol::HiveMetastore::HiveObjectRef();
        $xfer += $self->{hiveObject}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{principalName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{principalType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{grantInfo} = new Impala::Protocol::HiveMetastore::PrivilegeGrantInfo();
        $xfer += $self->{grantInfo}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('HiveObjectPrivilege');
  if (defined $self->{hiveObject}) {
    $xfer += $output->writeFieldBegin('hiveObject', TType::STRUCT, 1);
    $xfer += $self->{hiveObject}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{principalName}) {
    $xfer += $output->writeFieldBegin('principalName', TType::STRING, 2);
    $xfer += $output->writeString($self->{principalName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{principalType}) {
    $xfer += $output->writeFieldBegin('principalType', TType::I32, 3);
    $xfer += $output->writeI32($self->{principalType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{grantInfo}) {
    $xfer += $output->writeFieldBegin('grantInfo', TType::STRUCT, 4);
    $xfer += $self->{grantInfo}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::PrivilegeBag;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::PrivilegeBag->mk_accessors( qw( privileges ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{privileges} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{privileges}) {
      $self->{privileges} = $vals->{privileges};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'PrivilegeBag';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size7 = 0;
          $self->{privileges} = [];
          my $_etype10 = 0;
          $xfer += $input->readListBegin(\$_etype10, \$_size7);
          for (my $_i11 = 0; $_i11 < $_size7; ++$_i11)
          {
            my $elem12 = undef;
            $elem12 = new Impala::Protocol::HiveMetastore::HiveObjectPrivilege();
            $xfer += $elem12->read($input);
            push(@{$self->{privileges}},$elem12);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('PrivilegeBag');
  if (defined $self->{privileges}) {
    $xfer += $output->writeFieldBegin('privileges', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{privileges}}));
      {
        foreach my $iter13 (@{$self->{privileges}}) 
        {
          $xfer += ${iter13}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::PrincipalPrivilegeSet;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::PrincipalPrivilegeSet->mk_accessors( qw( userPrivileges groupPrivileges rolePrivileges ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{userPrivileges} = undef;
  $self->{groupPrivileges} = undef;
  $self->{rolePrivileges} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{userPrivileges}) {
      $self->{userPrivileges} = $vals->{userPrivileges};
    }
    if (defined $vals->{groupPrivileges}) {
      $self->{groupPrivileges} = $vals->{groupPrivileges};
    }
    if (defined $vals->{rolePrivileges}) {
      $self->{rolePrivileges} = $vals->{rolePrivileges};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'PrincipalPrivilegeSet';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size14 = 0;
          $self->{userPrivileges} = {};
          my $_ktype15 = 0;
          my $_vtype16 = 0;
          $xfer += $input->readMapBegin(\$_ktype15, \$_vtype16, \$_size14);
          for (my $_i18 = 0; $_i18 < $_size14; ++$_i18)
          {
            my $key19 = '';
            my $val20 = [];
            $xfer += $input->readString(\$key19);
            {
              my $_size21 = 0;
              $val20 = [];
              my $_etype24 = 0;
              $xfer += $input->readListBegin(\$_etype24, \$_size21);
              for (my $_i25 = 0; $_i25 < $_size21; ++$_i25)
              {
                my $elem26 = undef;
                $elem26 = new Impala::Protocol::HiveMetastore::PrivilegeGrantInfo();
                $xfer += $elem26->read($input);
                push(@{$val20},$elem26);
              }
              $xfer += $input->readListEnd();
            }
            $self->{userPrivileges}->{$key19} = $val20;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size27 = 0;
          $self->{groupPrivileges} = {};
          my $_ktype28 = 0;
          my $_vtype29 = 0;
          $xfer += $input->readMapBegin(\$_ktype28, \$_vtype29, \$_size27);
          for (my $_i31 = 0; $_i31 < $_size27; ++$_i31)
          {
            my $key32 = '';
            my $val33 = [];
            $xfer += $input->readString(\$key32);
            {
              my $_size34 = 0;
              $val33 = [];
              my $_etype37 = 0;
              $xfer += $input->readListBegin(\$_etype37, \$_size34);
              for (my $_i38 = 0; $_i38 < $_size34; ++$_i38)
              {
                my $elem39 = undef;
                $elem39 = new Impala::Protocol::HiveMetastore::PrivilegeGrantInfo();
                $xfer += $elem39->read($input);
                push(@{$val33},$elem39);
              }
              $xfer += $input->readListEnd();
            }
            $self->{groupPrivileges}->{$key32} = $val33;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size40 = 0;
          $self->{rolePrivileges} = {};
          my $_ktype41 = 0;
          my $_vtype42 = 0;
          $xfer += $input->readMapBegin(\$_ktype41, \$_vtype42, \$_size40);
          for (my $_i44 = 0; $_i44 < $_size40; ++$_i44)
          {
            my $key45 = '';
            my $val46 = [];
            $xfer += $input->readString(\$key45);
            {
              my $_size47 = 0;
              $val46 = [];
              my $_etype50 = 0;
              $xfer += $input->readListBegin(\$_etype50, \$_size47);
              for (my $_i51 = 0; $_i51 < $_size47; ++$_i51)
              {
                my $elem52 = undef;
                $elem52 = new Impala::Protocol::HiveMetastore::PrivilegeGrantInfo();
                $xfer += $elem52->read($input);
                push(@{$val46},$elem52);
              }
              $xfer += $input->readListEnd();
            }
            $self->{rolePrivileges}->{$key45} = $val46;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('PrincipalPrivilegeSet');
  if (defined $self->{userPrivileges}) {
    $xfer += $output->writeFieldBegin('userPrivileges', TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::LIST, scalar(keys %{$self->{userPrivileges}}));
      {
        while( my ($kiter53,$viter54) = each %{$self->{userPrivileges}}) 
        {
          $xfer += $output->writeString($kiter53);
          {
            $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{${viter54}}));
            {
              foreach my $iter55 (@{${viter54}}) 
              {
                $xfer += ${iter55}->write($output);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{groupPrivileges}) {
    $xfer += $output->writeFieldBegin('groupPrivileges', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::LIST, scalar(keys %{$self->{groupPrivileges}}));
      {
        while( my ($kiter56,$viter57) = each %{$self->{groupPrivileges}}) 
        {
          $xfer += $output->writeString($kiter56);
          {
            $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{${viter57}}));
            {
              foreach my $iter58 (@{${viter57}}) 
              {
                $xfer += ${iter58}->write($output);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rolePrivileges}) {
    $xfer += $output->writeFieldBegin('rolePrivileges', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::LIST, scalar(keys %{$self->{rolePrivileges}}));
      {
        while( my ($kiter59,$viter60) = each %{$self->{rolePrivileges}}) 
        {
          $xfer += $output->writeString($kiter59);
          {
            $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{${viter60}}));
            {
              foreach my $iter61 (@{${viter60}}) 
              {
                $xfer += ${iter61}->write($output);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::Role;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::Role->mk_accessors( qw( roleName createTime ownerName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{roleName} = undef;
  $self->{createTime} = undef;
  $self->{ownerName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{roleName}) {
      $self->{roleName} = $vals->{roleName};
    }
    if (defined $vals->{createTime}) {
      $self->{createTime} = $vals->{createTime};
    }
    if (defined $vals->{ownerName}) {
      $self->{ownerName} = $vals->{ownerName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Role';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{roleName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{createTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ownerName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Role');
  if (defined $self->{roleName}) {
    $xfer += $output->writeFieldBegin('roleName', TType::STRING, 1);
    $xfer += $output->writeString($self->{roleName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{createTime}) {
    $xfer += $output->writeFieldBegin('createTime', TType::I32, 2);
    $xfer += $output->writeI32($self->{createTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ownerName}) {
    $xfer += $output->writeFieldBegin('ownerName', TType::STRING, 3);
    $xfer += $output->writeString($self->{ownerName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::Database;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::Database->mk_accessors( qw( name description locationUri parameters privileges ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{description} = undef;
  $self->{locationUri} = undef;
  $self->{parameters} = undef;
  $self->{privileges} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{description}) {
      $self->{description} = $vals->{description};
    }
    if (defined $vals->{locationUri}) {
      $self->{locationUri} = $vals->{locationUri};
    }
    if (defined $vals->{parameters}) {
      $self->{parameters} = $vals->{parameters};
    }
    if (defined $vals->{privileges}) {
      $self->{privileges} = $vals->{privileges};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Database';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{description});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{locationUri});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size62 = 0;
          $self->{parameters} = {};
          my $_ktype63 = 0;
          my $_vtype64 = 0;
          $xfer += $input->readMapBegin(\$_ktype63, \$_vtype64, \$_size62);
          for (my $_i66 = 0; $_i66 < $_size62; ++$_i66)
          {
            my $key67 = '';
            my $val68 = '';
            $xfer += $input->readString(\$key67);
            $xfer += $input->readString(\$val68);
            $self->{parameters}->{$key67} = $val68;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{privileges} = new Impala::Protocol::HiveMetastore::PrincipalPrivilegeSet();
        $xfer += $self->{privileges}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Database');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{description}) {
    $xfer += $output->writeFieldBegin('description', TType::STRING, 2);
    $xfer += $output->writeString($self->{description});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{locationUri}) {
    $xfer += $output->writeFieldBegin('locationUri', TType::STRING, 3);
    $xfer += $output->writeString($self->{locationUri});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{parameters}) {
    $xfer += $output->writeFieldBegin('parameters', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{parameters}}));
      {
        while( my ($kiter69,$viter70) = each %{$self->{parameters}}) 
        {
          $xfer += $output->writeString($kiter69);
          $xfer += $output->writeString($viter70);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{privileges}) {
    $xfer += $output->writeFieldBegin('privileges', TType::STRUCT, 5);
    $xfer += $self->{privileges}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::SerDeInfo;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::SerDeInfo->mk_accessors( qw( name serializationLib parameters ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{serializationLib} = undef;
  $self->{parameters} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{serializationLib}) {
      $self->{serializationLib} = $vals->{serializationLib};
    }
    if (defined $vals->{parameters}) {
      $self->{parameters} = $vals->{parameters};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SerDeInfo';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{serializationLib});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size71 = 0;
          $self->{parameters} = {};
          my $_ktype72 = 0;
          my $_vtype73 = 0;
          $xfer += $input->readMapBegin(\$_ktype72, \$_vtype73, \$_size71);
          for (my $_i75 = 0; $_i75 < $_size71; ++$_i75)
          {
            my $key76 = '';
            my $val77 = '';
            $xfer += $input->readString(\$key76);
            $xfer += $input->readString(\$val77);
            $self->{parameters}->{$key76} = $val77;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SerDeInfo');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{serializationLib}) {
    $xfer += $output->writeFieldBegin('serializationLib', TType::STRING, 2);
    $xfer += $output->writeString($self->{serializationLib});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{parameters}) {
    $xfer += $output->writeFieldBegin('parameters', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{parameters}}));
      {
        while( my ($kiter78,$viter79) = each %{$self->{parameters}}) 
        {
          $xfer += $output->writeString($kiter78);
          $xfer += $output->writeString($viter79);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::Order;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::Order->mk_accessors( qw( col order ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{col} = undef;
  $self->{order} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{col}) {
      $self->{col} = $vals->{col};
    }
    if (defined $vals->{order}) {
      $self->{order} = $vals->{order};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Order';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{col});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{order});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Order');
  if (defined $self->{col}) {
    $xfer += $output->writeFieldBegin('col', TType::STRING, 1);
    $xfer += $output->writeString($self->{col});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{order}) {
    $xfer += $output->writeFieldBegin('order', TType::I32, 2);
    $xfer += $output->writeI32($self->{order});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::StorageDescriptor;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::StorageDescriptor->mk_accessors( qw( cols location inputFormat outputFormat compressed numBuckets serdeInfo bucketCols sortCols parameters ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cols} = undef;
  $self->{location} = undef;
  $self->{inputFormat} = undef;
  $self->{outputFormat} = undef;
  $self->{compressed} = undef;
  $self->{numBuckets} = undef;
  $self->{serdeInfo} = undef;
  $self->{bucketCols} = undef;
  $self->{sortCols} = undef;
  $self->{parameters} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cols}) {
      $self->{cols} = $vals->{cols};
    }
    if (defined $vals->{location}) {
      $self->{location} = $vals->{location};
    }
    if (defined $vals->{inputFormat}) {
      $self->{inputFormat} = $vals->{inputFormat};
    }
    if (defined $vals->{outputFormat}) {
      $self->{outputFormat} = $vals->{outputFormat};
    }
    if (defined $vals->{compressed}) {
      $self->{compressed} = $vals->{compressed};
    }
    if (defined $vals->{numBuckets}) {
      $self->{numBuckets} = $vals->{numBuckets};
    }
    if (defined $vals->{serdeInfo}) {
      $self->{serdeInfo} = $vals->{serdeInfo};
    }
    if (defined $vals->{bucketCols}) {
      $self->{bucketCols} = $vals->{bucketCols};
    }
    if (defined $vals->{sortCols}) {
      $self->{sortCols} = $vals->{sortCols};
    }
    if (defined $vals->{parameters}) {
      $self->{parameters} = $vals->{parameters};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StorageDescriptor';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size80 = 0;
          $self->{cols} = [];
          my $_etype83 = 0;
          $xfer += $input->readListBegin(\$_etype83, \$_size80);
          for (my $_i84 = 0; $_i84 < $_size80; ++$_i84)
          {
            my $elem85 = undef;
            $elem85 = new Impala::Protocol::HiveMetastore::FieldSchema();
            $xfer += $elem85->read($input);
            push(@{$self->{cols}},$elem85);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{location});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{inputFormat});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{outputFormat});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{compressed});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{numBuckets});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{serdeInfo} = new Impala::Protocol::HiveMetastore::SerDeInfo();
        $xfer += $self->{serdeInfo}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size86 = 0;
          $self->{bucketCols} = [];
          my $_etype89 = 0;
          $xfer += $input->readListBegin(\$_etype89, \$_size86);
          for (my $_i90 = 0; $_i90 < $_size86; ++$_i90)
          {
            my $elem91 = undef;
            $xfer += $input->readString(\$elem91);
            push(@{$self->{bucketCols}},$elem91);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size92 = 0;
          $self->{sortCols} = [];
          my $_etype95 = 0;
          $xfer += $input->readListBegin(\$_etype95, \$_size92);
          for (my $_i96 = 0; $_i96 < $_size92; ++$_i96)
          {
            my $elem97 = undef;
            $elem97 = new Impala::Protocol::HiveMetastore::Order();
            $xfer += $elem97->read($input);
            push(@{$self->{sortCols}},$elem97);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size98 = 0;
          $self->{parameters} = {};
          my $_ktype99 = 0;
          my $_vtype100 = 0;
          $xfer += $input->readMapBegin(\$_ktype99, \$_vtype100, \$_size98);
          for (my $_i102 = 0; $_i102 < $_size98; ++$_i102)
          {
            my $key103 = '';
            my $val104 = '';
            $xfer += $input->readString(\$key103);
            $xfer += $input->readString(\$val104);
            $self->{parameters}->{$key103} = $val104;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StorageDescriptor');
  if (defined $self->{cols}) {
    $xfer += $output->writeFieldBegin('cols', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{cols}}));
      {
        foreach my $iter105 (@{$self->{cols}}) 
        {
          $xfer += ${iter105}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{location}) {
    $xfer += $output->writeFieldBegin('location', TType::STRING, 2);
    $xfer += $output->writeString($self->{location});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{inputFormat}) {
    $xfer += $output->writeFieldBegin('inputFormat', TType::STRING, 3);
    $xfer += $output->writeString($self->{inputFormat});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{outputFormat}) {
    $xfer += $output->writeFieldBegin('outputFormat', TType::STRING, 4);
    $xfer += $output->writeString($self->{outputFormat});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compressed}) {
    $xfer += $output->writeFieldBegin('compressed', TType::BOOL, 5);
    $xfer += $output->writeBool($self->{compressed});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{numBuckets}) {
    $xfer += $output->writeFieldBegin('numBuckets', TType::I32, 6);
    $xfer += $output->writeI32($self->{numBuckets});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{serdeInfo}) {
    $xfer += $output->writeFieldBegin('serdeInfo', TType::STRUCT, 7);
    $xfer += $self->{serdeInfo}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{bucketCols}) {
    $xfer += $output->writeFieldBegin('bucketCols', TType::LIST, 8);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{bucketCols}}));
      {
        foreach my $iter106 (@{$self->{bucketCols}}) 
        {
          $xfer += $output->writeString($iter106);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sortCols}) {
    $xfer += $output->writeFieldBegin('sortCols', TType::LIST, 9);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{sortCols}}));
      {
        foreach my $iter107 (@{$self->{sortCols}}) 
        {
          $xfer += ${iter107}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{parameters}) {
    $xfer += $output->writeFieldBegin('parameters', TType::MAP, 10);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{parameters}}));
      {
        while( my ($kiter108,$viter109) = each %{$self->{parameters}}) 
        {
          $xfer += $output->writeString($kiter108);
          $xfer += $output->writeString($viter109);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::Table;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::Table->mk_accessors( qw( tableName dbName owner createTime lastAccessTime retention sd partitionKeys parameters viewOriginalText viewExpandedText tableType privileges ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{dbName} = undef;
  $self->{owner} = undef;
  $self->{createTime} = undef;
  $self->{lastAccessTime} = undef;
  $self->{retention} = undef;
  $self->{sd} = undef;
  $self->{partitionKeys} = undef;
  $self->{parameters} = undef;
  $self->{viewOriginalText} = undef;
  $self->{viewExpandedText} = undef;
  $self->{tableType} = undef;
  $self->{privileges} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{dbName}) {
      $self->{dbName} = $vals->{dbName};
    }
    if (defined $vals->{owner}) {
      $self->{owner} = $vals->{owner};
    }
    if (defined $vals->{createTime}) {
      $self->{createTime} = $vals->{createTime};
    }
    if (defined $vals->{lastAccessTime}) {
      $self->{lastAccessTime} = $vals->{lastAccessTime};
    }
    if (defined $vals->{retention}) {
      $self->{retention} = $vals->{retention};
    }
    if (defined $vals->{sd}) {
      $self->{sd} = $vals->{sd};
    }
    if (defined $vals->{partitionKeys}) {
      $self->{partitionKeys} = $vals->{partitionKeys};
    }
    if (defined $vals->{parameters}) {
      $self->{parameters} = $vals->{parameters};
    }
    if (defined $vals->{viewOriginalText}) {
      $self->{viewOriginalText} = $vals->{viewOriginalText};
    }
    if (defined $vals->{viewExpandedText}) {
      $self->{viewExpandedText} = $vals->{viewExpandedText};
    }
    if (defined $vals->{tableType}) {
      $self->{tableType} = $vals->{tableType};
    }
    if (defined $vals->{privileges}) {
      $self->{privileges} = $vals->{privileges};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Table';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dbName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{owner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{createTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{lastAccessTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{retention});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sd} = new Impala::Protocol::HiveMetastore::StorageDescriptor();
        $xfer += $self->{sd}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size110 = 0;
          $self->{partitionKeys} = [];
          my $_etype113 = 0;
          $xfer += $input->readListBegin(\$_etype113, \$_size110);
          for (my $_i114 = 0; $_i114 < $_size110; ++$_i114)
          {
            my $elem115 = undef;
            $elem115 = new Impala::Protocol::HiveMetastore::FieldSchema();
            $xfer += $elem115->read($input);
            push(@{$self->{partitionKeys}},$elem115);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size116 = 0;
          $self->{parameters} = {};
          my $_ktype117 = 0;
          my $_vtype118 = 0;
          $xfer += $input->readMapBegin(\$_ktype117, \$_vtype118, \$_size116);
          for (my $_i120 = 0; $_i120 < $_size116; ++$_i120)
          {
            my $key121 = '';
            my $val122 = '';
            $xfer += $input->readString(\$key121);
            $xfer += $input->readString(\$val122);
            $self->{parameters}->{$key121} = $val122;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{viewOriginalText});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{viewExpandedText});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{privileges} = new Impala::Protocol::HiveMetastore::PrincipalPrivilegeSet();
        $xfer += $self->{privileges}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Table');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{dbName}) {
    $xfer += $output->writeFieldBegin('dbName', TType::STRING, 2);
    $xfer += $output->writeString($self->{dbName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{owner}) {
    $xfer += $output->writeFieldBegin('owner', TType::STRING, 3);
    $xfer += $output->writeString($self->{owner});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{createTime}) {
    $xfer += $output->writeFieldBegin('createTime', TType::I32, 4);
    $xfer += $output->writeI32($self->{createTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{lastAccessTime}) {
    $xfer += $output->writeFieldBegin('lastAccessTime', TType::I32, 5);
    $xfer += $output->writeI32($self->{lastAccessTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{retention}) {
    $xfer += $output->writeFieldBegin('retention', TType::I32, 6);
    $xfer += $output->writeI32($self->{retention});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sd}) {
    $xfer += $output->writeFieldBegin('sd', TType::STRUCT, 7);
    $xfer += $self->{sd}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{partitionKeys}) {
    $xfer += $output->writeFieldBegin('partitionKeys', TType::LIST, 8);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{partitionKeys}}));
      {
        foreach my $iter123 (@{$self->{partitionKeys}}) 
        {
          $xfer += ${iter123}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{parameters}) {
    $xfer += $output->writeFieldBegin('parameters', TType::MAP, 9);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{parameters}}));
      {
        while( my ($kiter124,$viter125) = each %{$self->{parameters}}) 
        {
          $xfer += $output->writeString($kiter124);
          $xfer += $output->writeString($viter125);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{viewOriginalText}) {
    $xfer += $output->writeFieldBegin('viewOriginalText', TType::STRING, 10);
    $xfer += $output->writeString($self->{viewOriginalText});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{viewExpandedText}) {
    $xfer += $output->writeFieldBegin('viewExpandedText', TType::STRING, 11);
    $xfer += $output->writeString($self->{viewExpandedText});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tableType}) {
    $xfer += $output->writeFieldBegin('tableType', TType::STRING, 12);
    $xfer += $output->writeString($self->{tableType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{privileges}) {
    $xfer += $output->writeFieldBegin('privileges', TType::STRUCT, 13);
    $xfer += $self->{privileges}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::Partition;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::Partition->mk_accessors( qw( values dbName tableName createTime lastAccessTime sd parameters privileges ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{values} = undef;
  $self->{dbName} = undef;
  $self->{tableName} = undef;
  $self->{createTime} = undef;
  $self->{lastAccessTime} = undef;
  $self->{sd} = undef;
  $self->{parameters} = undef;
  $self->{privileges} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{values}) {
      $self->{values} = $vals->{values};
    }
    if (defined $vals->{dbName}) {
      $self->{dbName} = $vals->{dbName};
    }
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{createTime}) {
      $self->{createTime} = $vals->{createTime};
    }
    if (defined $vals->{lastAccessTime}) {
      $self->{lastAccessTime} = $vals->{lastAccessTime};
    }
    if (defined $vals->{sd}) {
      $self->{sd} = $vals->{sd};
    }
    if (defined $vals->{parameters}) {
      $self->{parameters} = $vals->{parameters};
    }
    if (defined $vals->{privileges}) {
      $self->{privileges} = $vals->{privileges};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Partition';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size126 = 0;
          $self->{values} = [];
          my $_etype129 = 0;
          $xfer += $input->readListBegin(\$_etype129, \$_size126);
          for (my $_i130 = 0; $_i130 < $_size126; ++$_i130)
          {
            my $elem131 = undef;
            $xfer += $input->readString(\$elem131);
            push(@{$self->{values}},$elem131);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dbName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{createTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{lastAccessTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sd} = new Impala::Protocol::HiveMetastore::StorageDescriptor();
        $xfer += $self->{sd}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size132 = 0;
          $self->{parameters} = {};
          my $_ktype133 = 0;
          my $_vtype134 = 0;
          $xfer += $input->readMapBegin(\$_ktype133, \$_vtype134, \$_size132);
          for (my $_i136 = 0; $_i136 < $_size132; ++$_i136)
          {
            my $key137 = '';
            my $val138 = '';
            $xfer += $input->readString(\$key137);
            $xfer += $input->readString(\$val138);
            $self->{parameters}->{$key137} = $val138;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{privileges} = new Impala::Protocol::HiveMetastore::PrincipalPrivilegeSet();
        $xfer += $self->{privileges}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Partition');
  if (defined $self->{values}) {
    $xfer += $output->writeFieldBegin('values', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{values}}));
      {
        foreach my $iter139 (@{$self->{values}}) 
        {
          $xfer += $output->writeString($iter139);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{dbName}) {
    $xfer += $output->writeFieldBegin('dbName', TType::STRING, 2);
    $xfer += $output->writeString($self->{dbName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 3);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{createTime}) {
    $xfer += $output->writeFieldBegin('createTime', TType::I32, 4);
    $xfer += $output->writeI32($self->{createTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{lastAccessTime}) {
    $xfer += $output->writeFieldBegin('lastAccessTime', TType::I32, 5);
    $xfer += $output->writeI32($self->{lastAccessTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sd}) {
    $xfer += $output->writeFieldBegin('sd', TType::STRUCT, 6);
    $xfer += $self->{sd}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{parameters}) {
    $xfer += $output->writeFieldBegin('parameters', TType::MAP, 7);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{parameters}}));
      {
        while( my ($kiter140,$viter141) = each %{$self->{parameters}}) 
        {
          $xfer += $output->writeString($kiter140);
          $xfer += $output->writeString($viter141);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{privileges}) {
    $xfer += $output->writeFieldBegin('privileges', TType::STRUCT, 8);
    $xfer += $self->{privileges}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::Index;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::Index->mk_accessors( qw( indexName indexHandlerClass dbName origTableName createTime lastAccessTime indexTableName sd parameters deferredRebuild ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{indexName} = undef;
  $self->{indexHandlerClass} = undef;
  $self->{dbName} = undef;
  $self->{origTableName} = undef;
  $self->{createTime} = undef;
  $self->{lastAccessTime} = undef;
  $self->{indexTableName} = undef;
  $self->{sd} = undef;
  $self->{parameters} = undef;
  $self->{deferredRebuild} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{indexName}) {
      $self->{indexName} = $vals->{indexName};
    }
    if (defined $vals->{indexHandlerClass}) {
      $self->{indexHandlerClass} = $vals->{indexHandlerClass};
    }
    if (defined $vals->{dbName}) {
      $self->{dbName} = $vals->{dbName};
    }
    if (defined $vals->{origTableName}) {
      $self->{origTableName} = $vals->{origTableName};
    }
    if (defined $vals->{createTime}) {
      $self->{createTime} = $vals->{createTime};
    }
    if (defined $vals->{lastAccessTime}) {
      $self->{lastAccessTime} = $vals->{lastAccessTime};
    }
    if (defined $vals->{indexTableName}) {
      $self->{indexTableName} = $vals->{indexTableName};
    }
    if (defined $vals->{sd}) {
      $self->{sd} = $vals->{sd};
    }
    if (defined $vals->{parameters}) {
      $self->{parameters} = $vals->{parameters};
    }
    if (defined $vals->{deferredRebuild}) {
      $self->{deferredRebuild} = $vals->{deferredRebuild};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Index';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{indexName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{indexHandlerClass});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dbName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{origTableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{createTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{lastAccessTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{indexTableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sd} = new Impala::Protocol::HiveMetastore::StorageDescriptor();
        $xfer += $self->{sd}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size142 = 0;
          $self->{parameters} = {};
          my $_ktype143 = 0;
          my $_vtype144 = 0;
          $xfer += $input->readMapBegin(\$_ktype143, \$_vtype144, \$_size142);
          for (my $_i146 = 0; $_i146 < $_size142; ++$_i146)
          {
            my $key147 = '';
            my $val148 = '';
            $xfer += $input->readString(\$key147);
            $xfer += $input->readString(\$val148);
            $self->{parameters}->{$key147} = $val148;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deferredRebuild});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Index');
  if (defined $self->{indexName}) {
    $xfer += $output->writeFieldBegin('indexName', TType::STRING, 1);
    $xfer += $output->writeString($self->{indexName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{indexHandlerClass}) {
    $xfer += $output->writeFieldBegin('indexHandlerClass', TType::STRING, 2);
    $xfer += $output->writeString($self->{indexHandlerClass});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{dbName}) {
    $xfer += $output->writeFieldBegin('dbName', TType::STRING, 3);
    $xfer += $output->writeString($self->{dbName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{origTableName}) {
    $xfer += $output->writeFieldBegin('origTableName', TType::STRING, 4);
    $xfer += $output->writeString($self->{origTableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{createTime}) {
    $xfer += $output->writeFieldBegin('createTime', TType::I32, 5);
    $xfer += $output->writeI32($self->{createTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{lastAccessTime}) {
    $xfer += $output->writeFieldBegin('lastAccessTime', TType::I32, 6);
    $xfer += $output->writeI32($self->{lastAccessTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{indexTableName}) {
    $xfer += $output->writeFieldBegin('indexTableName', TType::STRING, 7);
    $xfer += $output->writeString($self->{indexTableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sd}) {
    $xfer += $output->writeFieldBegin('sd', TType::STRUCT, 8);
    $xfer += $self->{sd}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{parameters}) {
    $xfer += $output->writeFieldBegin('parameters', TType::MAP, 9);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{parameters}}));
      {
        while( my ($kiter149,$viter150) = each %{$self->{parameters}}) 
        {
          $xfer += $output->writeString($kiter149);
          $xfer += $output->writeString($viter150);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deferredRebuild}) {
    $xfer += $output->writeFieldBegin('deferredRebuild', TType::BOOL, 10);
    $xfer += $output->writeBool($self->{deferredRebuild});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::Schema;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::Schema->mk_accessors( qw( fieldSchemas properties ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{fieldSchemas} = undef;
  $self->{properties} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{fieldSchemas}) {
      $self->{fieldSchemas} = $vals->{fieldSchemas};
    }
    if (defined $vals->{properties}) {
      $self->{properties} = $vals->{properties};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Schema';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size151 = 0;
          $self->{fieldSchemas} = [];
          my $_etype154 = 0;
          $xfer += $input->readListBegin(\$_etype154, \$_size151);
          for (my $_i155 = 0; $_i155 < $_size151; ++$_i155)
          {
            my $elem156 = undef;
            $elem156 = new Impala::Protocol::HiveMetastore::FieldSchema();
            $xfer += $elem156->read($input);
            push(@{$self->{fieldSchemas}},$elem156);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size157 = 0;
          $self->{properties} = {};
          my $_ktype158 = 0;
          my $_vtype159 = 0;
          $xfer += $input->readMapBegin(\$_ktype158, \$_vtype159, \$_size157);
          for (my $_i161 = 0; $_i161 < $_size157; ++$_i161)
          {
            my $key162 = '';
            my $val163 = '';
            $xfer += $input->readString(\$key162);
            $xfer += $input->readString(\$val163);
            $self->{properties}->{$key162} = $val163;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Schema');
  if (defined $self->{fieldSchemas}) {
    $xfer += $output->writeFieldBegin('fieldSchemas', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{fieldSchemas}}));
      {
        foreach my $iter164 (@{$self->{fieldSchemas}}) 
        {
          $xfer += ${iter164}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{properties}) {
    $xfer += $output->writeFieldBegin('properties', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{properties}}));
      {
        while( my ($kiter165,$viter166) = each %{$self->{properties}}) 
        {
          $xfer += $output->writeString($kiter165);
          $xfer += $output->writeString($viter166);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::EnvironmentContext;
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::EnvironmentContext->mk_accessors( qw( properties ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{properties} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{properties}) {
      $self->{properties} = $vals->{properties};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'EnvironmentContext';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size167 = 0;
          $self->{properties} = {};
          my $_ktype168 = 0;
          my $_vtype169 = 0;
          $xfer += $input->readMapBegin(\$_ktype168, \$_vtype169, \$_size167);
          for (my $_i171 = 0; $_i171 < $_size167; ++$_i171)
          {
            my $key172 = '';
            my $val173 = '';
            $xfer += $input->readString(\$key172);
            $xfer += $input->readString(\$val173);
            $self->{properties}->{$key172} = $val173;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('EnvironmentContext');
  if (defined $self->{properties}) {
    $xfer += $output->writeFieldBegin('properties', TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{properties}}));
      {
        while( my ($kiter174,$viter175) = each %{$self->{properties}}) 
        {
          $xfer += $output->writeString($kiter174);
          $xfer += $output->writeString($viter175);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::MetaException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::MetaException->mk_accessors( qw( message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'MetaException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('MetaException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::UnknownTableException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::UnknownTableException->mk_accessors( qw( message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UnknownTableException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UnknownTableException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::UnknownDBException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::UnknownDBException->mk_accessors( qw( message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UnknownDBException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UnknownDBException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::AlreadyExistsException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::AlreadyExistsException->mk_accessors( qw( message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AlreadyExistsException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AlreadyExistsException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::InvalidPartitionException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::InvalidPartitionException->mk_accessors( qw( message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'InvalidPartitionException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('InvalidPartitionException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::UnknownPartitionException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::UnknownPartitionException->mk_accessors( qw( message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UnknownPartitionException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UnknownPartitionException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::InvalidObjectException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::InvalidObjectException->mk_accessors( qw( message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'InvalidObjectException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('InvalidObjectException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::NoSuchObjectException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::NoSuchObjectException->mk_accessors( qw( message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoSuchObjectException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoSuchObjectException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::IndexAlreadyExistsException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::IndexAlreadyExistsException->mk_accessors( qw( message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'IndexAlreadyExistsException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('IndexAlreadyExistsException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::InvalidOperationException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::InvalidOperationException->mk_accessors( qw( message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'InvalidOperationException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('InvalidOperationException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::HiveMetastore::ConfigValSecurityException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Impala::Protocol::HiveMetastore::ConfigValSecurityException->mk_accessors( qw( message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ConfigValSecurityException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ConfigValSecurityException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

1;
