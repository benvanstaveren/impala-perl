#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

package
	Impala::Protocol::Beeswax::QueryState;
use constant CREATED => 0;
use constant INITIALIZED => 1;
use constant COMPILED => 2;
use constant RUNNING => 3;
use constant FINISHED => 4;
use constant EXCEPTION => 5;
package
	Impala::Protocol::Beeswax::Query;
use base qw(Class::Accessor);
Impala::Protocol::Beeswax::Query->mk_accessors( qw( query configuration hadoop_user ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{query} = undef;
  $self->{configuration} = undef;
  $self->{hadoop_user} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{configuration}) {
      $self->{configuration} = $vals->{configuration};
    }
    if (defined $vals->{hadoop_user}) {
      $self->{hadoop_user} = $vals->{hadoop_user};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Query';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{query});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size0 = 0;
          $self->{configuration} = [];
          my $_etype3 = 0;
          $xfer += $input->readListBegin(\$_etype3, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $elem5 = undef;
            $xfer += $input->readString(\$elem5);
            push(@{$self->{configuration}},$elem5);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{hadoop_user});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Query');
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRING, 1);
    $xfer += $output->writeString($self->{query});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{configuration}) {
    $xfer += $output->writeFieldBegin('configuration', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{configuration}}));
      {
        foreach my $iter6 (@{$self->{configuration}}) 
        {
          $xfer += $output->writeString($iter6);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{hadoop_user}) {
    $xfer += $output->writeFieldBegin('hadoop_user', TType::STRING, 4);
    $xfer += $output->writeString($self->{hadoop_user});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::Beeswax::QueryHandle;
use base qw(Class::Accessor);
Impala::Protocol::Beeswax::QueryHandle->mk_accessors( qw( id log_context ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{id} = undef;
  $self->{log_context} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{log_context}) {
      $self->{log_context} = $vals->{log_context};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'QueryHandle';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{log_context});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('QueryHandle');
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
    $xfer += $output->writeString($self->{id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{log_context}) {
    $xfer += $output->writeFieldBegin('log_context', TType::STRING, 2);
    $xfer += $output->writeString($self->{log_context});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::Beeswax::QueryExplanation;
use base qw(Class::Accessor);
Impala::Protocol::Beeswax::QueryExplanation->mk_accessors( qw( textual ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{textual} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{textual}) {
      $self->{textual} = $vals->{textual};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'QueryExplanation';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{textual});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('QueryExplanation');
  if (defined $self->{textual}) {
    $xfer += $output->writeFieldBegin('textual', TType::STRING, 1);
    $xfer += $output->writeString($self->{textual});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::Beeswax::Results;
use base qw(Class::Accessor);
Impala::Protocol::Beeswax::Results->mk_accessors( qw( ready columns data start_row has_more ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ready} = undef;
  $self->{columns} = undef;
  $self->{data} = undef;
  $self->{start_row} = undef;
  $self->{has_more} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ready}) {
      $self->{ready} = $vals->{ready};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{data}) {
      $self->{data} = $vals->{data};
    }
    if (defined $vals->{start_row}) {
      $self->{start_row} = $vals->{start_row};
    }
    if (defined $vals->{has_more}) {
      $self->{has_more} = $vals->{has_more};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Results';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{ready});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size7 = 0;
          $self->{columns} = [];
          my $_etype10 = 0;
          $xfer += $input->readListBegin(\$_etype10, \$_size7);
          for (my $_i11 = 0; $_i11 < $_size7; ++$_i11)
          {
            my $elem12 = undef;
            $xfer += $input->readString(\$elem12);
            push(@{$self->{columns}},$elem12);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size13 = 0;
          $self->{data} = [];
          my $_etype16 = 0;
          $xfer += $input->readListBegin(\$_etype16, \$_size13);
          for (my $_i17 = 0; $_i17 < $_size13; ++$_i17)
          {
            my $elem18 = undef;
            $xfer += $input->readString(\$elem18);
            push(@{$self->{data}},$elem18);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{start_row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{has_more});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Results');
  if (defined $self->{ready}) {
    $xfer += $output->writeFieldBegin('ready', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{ready});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter19 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter19);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{data}) {
    $xfer += $output->writeFieldBegin('data', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{data}}));
      {
        foreach my $iter20 (@{$self->{data}}) 
        {
          $xfer += $output->writeString($iter20);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start_row}) {
    $xfer += $output->writeFieldBegin('start_row', TType::I64, 4);
    $xfer += $output->writeI64($self->{start_row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{has_more}) {
    $xfer += $output->writeFieldBegin('has_more', TType::BOOL, 5);
    $xfer += $output->writeBool($self->{has_more});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::Beeswax::ResultsMetadata;
use base qw(Class::Accessor);
Impala::Protocol::Beeswax::ResultsMetadata->mk_accessors( qw( schema table_dir in_tablename delim ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{schema} = undef;
  $self->{table_dir} = undef;
  $self->{in_tablename} = undef;
  $self->{delim} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{schema}) {
      $self->{schema} = $vals->{schema};
    }
    if (defined $vals->{table_dir}) {
      $self->{table_dir} = $vals->{table_dir};
    }
    if (defined $vals->{in_tablename}) {
      $self->{in_tablename} = $vals->{in_tablename};
    }
    if (defined $vals->{delim}) {
      $self->{delim} = $vals->{delim};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ResultsMetadata';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{schema} = new Impala::Protocol::HiveMetastore::Schema();
        $xfer += $self->{schema}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_dir});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{in_tablename});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{delim});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ResultsMetadata');
  if (defined $self->{schema}) {
    $xfer += $output->writeFieldBegin('schema', TType::STRUCT, 1);
    $xfer += $self->{schema}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_dir}) {
    $xfer += $output->writeFieldBegin('table_dir', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_dir});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{in_tablename}) {
    $xfer += $output->writeFieldBegin('in_tablename', TType::STRING, 3);
    $xfer += $output->writeString($self->{in_tablename});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{delim}) {
    $xfer += $output->writeFieldBegin('delim', TType::STRING, 4);
    $xfer += $output->writeString($self->{delim});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::Beeswax::BeeswaxException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Impala::Protocol::Beeswax::BeeswaxException->mk_accessors( qw( message log_context handle errorCode SQLState ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  $self->{log_context} = undef;
  $self->{handle} = undef;
  $self->{errorCode} = 0;
  $self->{SQLState} = "     ";
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
    if (defined $vals->{log_context}) {
      $self->{log_context} = $vals->{log_context};
    }
    if (defined $vals->{handle}) {
      $self->{handle} = $vals->{handle};
    }
    if (defined $vals->{errorCode}) {
      $self->{errorCode} = $vals->{errorCode};
    }
    if (defined $vals->{SQLState}) {
      $self->{SQLState} = $vals->{SQLState};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BeeswaxException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{log_context});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{handle} = new Impala::Protocol::Beeswax::QueryHandle();
        $xfer += $self->{handle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{errorCode});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{SQLState});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BeeswaxException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{log_context}) {
    $xfer += $output->writeFieldBegin('log_context', TType::STRING, 2);
    $xfer += $output->writeString($self->{log_context});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{handle}) {
    $xfer += $output->writeFieldBegin('handle', TType::STRUCT, 3);
    $xfer += $self->{handle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{errorCode}) {
    $xfer += $output->writeFieldBegin('errorCode', TType::I32, 4);
    $xfer += $output->writeI32($self->{errorCode});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{SQLState}) {
    $xfer += $output->writeFieldBegin('SQLState', TType::STRING, 5);
    $xfer += $output->writeString($self->{SQLState});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::Beeswax::QueryNotFoundException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'QueryNotFoundException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('QueryNotFoundException');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
	Impala::Protocol::Beeswax::ConfigVariable;
use base qw(Class::Accessor);
Impala::Protocol::Beeswax::ConfigVariable->mk_accessors( qw( key value description ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{value} = undef;
  $self->{description} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{description}) {
      $self->{description} = $vals->{description};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ConfigVariable';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{description});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ConfigVariable');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 2);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{description}) {
    $xfer += $output->writeFieldBegin('description', TType::STRING, 3);
    $xfer += $output->writeString($self->{description});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

1;
